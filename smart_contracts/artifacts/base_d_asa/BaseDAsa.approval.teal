#pragma version 10
#pragma typetrack false

// smart_contracts.base_d_asa.contract.BaseDAsa.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 0 1 8 4 200
    bytecblock 0x151f7c75 "circulating_units" "status" "maturity_date" "unit_value" "total_units" "total_coupons" 0x52333023 0x52323023 "denomination_asset_id" "settlement_asset_id" "day_count_convention" "primary_distribution_opening_date" "primary_distribution_closure_date" "issuance_date" "secondary_market_opening_date" "secondary_market_closure_date" "suspended" "defaulted" "metadata" "interest_rate" 0x74696d654576656e7473 0x52373023 0x52363023 0x52353023 0x52343023 0x0000000000000000 0x636f75706f6e5261746573 0x068101 0x52383023
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/base_d_asa/contract.py:41-42
    // # Role Based Access Control
    // self.arranger = GlobalState(Account(), key=cst.PREFIX_ID_ARRANGER)
    bytec 8 // 0x52323023
    global ZeroAddress
    app_global_put
    // smart_contracts/base_d_asa/contract.py:59-60
    // # Asset Configuration
    // self.denomination_asset_id = UInt64()
    bytec 9 // "denomination_asset_id"
    intc_0 // 0
    app_global_put
    // smart_contracts/base_d_asa/contract.py:61
    // self.settlement_asset_id = UInt64()
    bytec 10 // "settlement_asset_id"
    intc_0 // 0
    app_global_put
    // smart_contracts/base_d_asa/contract.py:62
    // self.unit_value = UInt64()
    bytec 4 // "unit_value"
    intc_0 // 0
    app_global_put
    // smart_contracts/base_d_asa/contract.py:63
    // self.day_count_convention = UInt64()
    bytec 11 // "day_count_convention"
    intc_0 // 0
    app_global_put
    // smart_contracts/base_d_asa/contract.py:65-66
    // # Metadata
    // self.metadata = Bytes()
    bytec 19 // "metadata"
    pushbytes 0x
    app_global_put
    // smart_contracts/base_d_asa/contract.py:68-69
    // # Supply
    // self.total_units = UInt64()
    bytec 5 // "total_units"
    intc_0 // 0
    app_global_put
    // smart_contracts/base_d_asa/contract.py:70
    // self.circulating_units = UInt64()
    bytec_1 // "circulating_units"
    intc_0 // 0
    app_global_put
    // smart_contracts/base_d_asa/contract.py:72-73
    // # Interest
    // self.interest_rate = UInt64()
    bytec 20 // "interest_rate"
    intc_0 // 0
    app_global_put
    // smart_contracts/base_d_asa/contract.py:77
    // self.total_coupons = UInt64()
    bytec 6 // "total_coupons"
    intc_0 // 0
    app_global_put
    // smart_contracts/base_d_asa/contract.py:82
    // self.primary_distribution_opening_date = UInt64()
    bytec 12 // "primary_distribution_opening_date"
    intc_0 // 0
    app_global_put
    // smart_contracts/base_d_asa/contract.py:83
    // self.primary_distribution_closure_date = UInt64()
    bytec 13 // "primary_distribution_closure_date"
    intc_0 // 0
    app_global_put
    // smart_contracts/base_d_asa/contract.py:84
    // self.issuance_date = UInt64()
    bytec 14 // "issuance_date"
    intc_0 // 0
    app_global_put
    // smart_contracts/base_d_asa/contract.py:85
    // self.secondary_market_opening_date = UInt64()
    bytec 15 // "secondary_market_opening_date"
    intc_0 // 0
    app_global_put
    // smart_contracts/base_d_asa/contract.py:86
    // self.secondary_market_closure_date = UInt64()
    bytec 16 // "secondary_market_closure_date"
    intc_0 // 0
    app_global_put
    // smart_contracts/base_d_asa/contract.py:87
    // self.maturity_date = UInt64()
    bytec_3 // "maturity_date"
    intc_0 // 0
    app_global_put
    // smart_contracts/base_d_asa/contract.py:89-90
    // # Status
    // self.status = UInt64(cfg.STATUS_EMPTY)
    bytec_2 // "status"
    intc_0 // 0
    app_global_put
    // smart_contracts/base_d_asa/contract.py:91
    // self.suspended = UInt64()
    bytec 17 // "suspended"
    intc_0 // 0
    app_global_put
    // smart_contracts/base_d_asa/contract.py:92
    // self.defaulted = UInt64()
    bytec 18 // "defaulted"
    intc_0 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/base_d_asa/contract.py:28
    // class BaseDAsa(ARC4Contract):
    txn NumAppArgs
    bz main_bare_routing@21
    pushbytess 0x3f0efc6c 0xd3a4d6ab 0x1d6fc255 0xfef74567 0xb8fc1390 0x3d43d1f0 0xebd96b2f 0x6c85e3ee 0xf63ace8d 0xbbcca18a 0x1a7babb4 0x1460a966 0xed02759f 0xfad2173e 0x08efea35 0xe4a5ab54 // method "asset_create(address,(uint8,uint8,uint8,uint8,uint8,uint8,byte[32],string))void", method "asset_config(uint64,uint64,uint64,uint64,uint8,uint16,uint16[],uint64[],(uint64,uint64)[])void", method "set_secondary_time_events(uint64[])(uint64,uint64)", method "assign_role(address,uint8,byte[])uint64", method "revoke_role(address,uint8)uint64", method "open_account(address,address)uint64", method "close_account(address)(uint64,uint64)", method "primary_distribution(address,uint64)uint64", method "set_asset_suspension(bool)uint64", method "set_account_suspension(address,bool)uint64", method "set_default_status(bool)void", method "get_asset_info()(uint64,uint64,uint64,uint64,uint8,uint16,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint8)", method "get_account_info(address)(address,uint64,uint64,uint64,bool)", method "get_time_events()uint64[]", method "get_secondary_market_schedule()uint64[]", method "get_asset_metadata()(uint8,uint8,uint8,uint8,uint8,uint8,byte[32],string)"
    txna ApplicationArgs 0
    match main_asset_create_route@5 main_asset_config_route@6 main_set_secondary_time_events_route@7 main_assign_role_route@8 main_revoke_role_route@9 main_open_account_route@10 main_close_account_route@11 main_primary_distribution_route@12 main_set_asset_suspension_route@13 main_set_account_suspension_route@14 main_set_default_status_route@15 main_get_asset_info_route@16 main_get_account_info_route@17 main_get_time_events_route@18 main_get_secondary_market_schedule_route@19 main_get_asset_metadata_route@20

main_after_if_else@23:
    // smart_contracts/base_d_asa/contract.py:28
    // class BaseDAsa(ARC4Contract):
    intc_0 // 0
    return

main_get_asset_metadata_route@20:
    // smart_contracts/base_d_asa/contract.py:970
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_asset_metadata
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_secondary_market_schedule_route@19:
    // smart_contracts/base_d_asa/contract.py:957
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_secondary_market_schedule
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_time_events_route@18:
    // smart_contracts/base_d_asa/contract.py:944
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_time_events
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_account_info_route@17:
    // smart_contracts/base_d_asa/contract.py:927
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/base_d_asa/contract.py:28
    // class BaseDAsa(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/base_d_asa/contract.py:927
    // @arc4.abimethod(readonly=True)
    callsub get_account_info
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_asset_info_route@16:
    // smart_contracts/base_d_asa/contract.py:889
    // @arc4.abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub get_asset_info
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_set_default_status_route@15:
    // smart_contracts/base_d_asa/contract.py:875
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/base_d_asa/contract.py:28
    // class BaseDAsa(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/base_d_asa/contract.py:875
    // @arc4.abimethod
    callsub set_default_status
    intc_1 // 1
    return

main_set_account_suspension_route@14:
    // smart_contracts/base_d_asa/contract.py:852
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/base_d_asa/contract.py:28
    // class BaseDAsa(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/base_d_asa/contract.py:852
    // @arc4.abimethod
    callsub set_account_suspension
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_set_asset_suspension_route@13:
    // smart_contracts/base_d_asa/contract.py:834
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/base_d_asa/contract.py:28
    // class BaseDAsa(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/base_d_asa/contract.py:834
    // @arc4.abimethod
    callsub set_asset_suspension
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_primary_distribution_route@12:
    // smart_contracts/base_d_asa/contract.py:792
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/base_d_asa/contract.py:28
    // class BaseDAsa(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/base_d_asa/contract.py:792
    // @arc4.abimethod
    callsub primary_distribution
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_close_account_route@11:
    // smart_contracts/base_d_asa/contract.py:762
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/base_d_asa/contract.py:28
    // class BaseDAsa(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/base_d_asa/contract.py:762
    // @arc4.abimethod
    callsub close_account
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_open_account_route@10:
    // smart_contracts/base_d_asa/contract.py:727
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/base_d_asa/contract.py:28
    // class BaseDAsa(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/base_d_asa/contract.py:727
    // @arc4.abimethod
    callsub open_account
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_revoke_role_route@9:
    // smart_contracts/base_d_asa/contract.py:679
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/base_d_asa/contract.py:28
    // class BaseDAsa(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/base_d_asa/contract.py:679
    // @arc4.abimethod
    callsub revoke_role
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_assign_role_route@8:
    // smart_contracts/base_d_asa/contract.py:616
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/base_d_asa/contract.py:28
    // class BaseDAsa(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    // smart_contracts/base_d_asa/contract.py:616
    // @arc4.abimethod
    callsub assign_role
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_set_secondary_time_events_route@7:
    // smart_contracts/base_d_asa/contract.py:560
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/base_d_asa/contract.py:28
    // class BaseDAsa(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/base_d_asa/contract.py:560
    // @arc4.abimethod
    callsub set_secondary_time_events
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_asset_config_route@6:
    // smart_contracts/base_d_asa/contract.py:478
    // @arc4.abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/base_d_asa/contract.py:28
    // class BaseDAsa(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    txna ApplicationArgs 5
    txna ApplicationArgs 6
    txna ApplicationArgs 7
    txna ApplicationArgs 8
    txna ApplicationArgs 9
    // smart_contracts/base_d_asa/contract.py:478
    // @arc4.abimethod
    callsub asset_config
    intc_1 // 1
    return

main_asset_create_route@5:
    // smart_contracts/base_d_asa/contract.py:456
    // @arc4.abimethod(create="require")
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    !
    assert // can only call when creating
    // smart_contracts/base_d_asa/contract.py:28
    // class BaseDAsa(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/base_d_asa/contract.py:456
    // @arc4.abimethod(create="require")
    callsub asset_create
    intc_1 // 1
    return

main_bare_routing@21:
    // smart_contracts/base_d_asa/contract.py:28
    // class BaseDAsa(ARC4Contract):
    intc_3 // 4
    txn OnCompletion
    match main_asset_update@22
    b main_after_if_else@23

main_asset_update@22:
    // smart_contracts/base_d_asa/contract.py:468
    // @arc4.baremethod(allow_actions=["UpdateApplication"])
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/base_d_asa/contract.py:468-469
    // @arc4.baremethod(allow_actions=["UpdateApplication"])
    // def asset_update(self) -> None:
    callsub asset_update
    intc_1 // 1
    return


// smart_contracts.base_d_asa.contract.BaseDAsa.asset_create(arranger: bytes, metadata: bytes) -> void:
asset_create:
    // smart_contracts/base_d_asa/contract.py:456-457
    // @arc4.abimethod(create="require")
    // def asset_create(self, arranger: arc4.Address, metadata: typ.AssetMetadata) -> None:
    proto 2 0
    // smart_contracts/base_d_asa/contract.py:465
    // self.arranger.value = arranger.native
    bytec 8 // 0x52323023
    frame_dig -2
    app_global_put
    // smart_contracts/base_d_asa/contract.py:466
    // self.metadata = metadata.bytes
    bytec 19 // "metadata"
    frame_dig -1
    app_global_put
    retsub


// smart_contracts.base_d_asa.contract.BaseDAsa.asset_config(denomination_asset_id: bytes, settlement_asset_id: bytes, principal: bytes, minimum_denomination: bytes, day_count_convention: bytes, interest_rate: bytes, coupon_rates: bytes, time_events: bytes, time_periods: bytes) -> void:
asset_config:
    // smart_contracts/base_d_asa/contract.py:478-490
    // @arc4.abimethod
    // def asset_config(
    //     self,
    //     denomination_asset_id: arc4.UInt64,
    //     settlement_asset_id: arc4.UInt64,
    //     principal: arc4.UInt64,
    //     minimum_denomination: arc4.UInt64,
    //     day_count_convention: arc4.UInt8,
    //     interest_rate: arc4.UInt16,
    //     coupon_rates: typ.CouponRates,
    //     time_events: typ.TimeEvents,
    //     time_periods: typ.TimePeriods,
    // ) -> None:
    proto 9 0
    intc_0 // 0
    pushbytes ""
    dup
    // smart_contracts/base_d_asa/contract.py:519
    // self.assert_caller_is_arranger()
    callsub assert_caller_is_arranger
    // smart_contracts/base_d_asa/contract.py:520
    // assert self.status == cfg.STATUS_EMPTY, err.ALREADY_CONFIGURED
    intc_0 // 0
    bytec_2 // "status"
    app_global_get_ex
    assert // check self.status exists
    !
    assert // D-ASA already configured
    // smart_contracts/base_d_asa/contract.py:522-523
    // # Set Denomination Asset
    // self.assert_denomination_asset(denomination_asset_id.native)
    frame_dig -9
    btoi
    dup
    // smart_contracts/base_d_asa/contract.py:177
    // denomination_asset_id != UInt64(0) and Asset(denomination_asset_id).creator
    bz asset_config_bool_false@4
    frame_dig 3
    asset_params_get AssetCreator
    assert // asset exists
    global ZeroAddress
    !=
    bz asset_config_bool_false@4
    intc_1 // 1

asset_config_bool_merge@5:
    // smart_contracts/base_d_asa/contract.py:175-178
    // # The reference implementation has on-chain denomination with ASA
    // assert (
    //     denomination_asset_id != UInt64(0) and Asset(denomination_asset_id).creator
    // ), err.INVALID_DENOMINATION
    assert // Denomination asset is not properly set
    // smart_contracts/base_d_asa/contract.py:182
    // self.denomination_asset_id = denomination_asset_id
    bytec 9 // "denomination_asset_id"
    frame_dig 3
    app_global_put
    // smart_contracts/base_d_asa/contract.py:526-527
    // # Set Denomination Asset
    // self.assert_settlement_asset(settlement_asset_id.native)
    frame_dig -8
    btoi
    // smart_contracts/base_d_asa/contract.py:188
    // settlement_asset_id == self.denomination_asset_id
    intc_0 // 0
    bytec 9 // "denomination_asset_id"
    app_global_get_ex
    assert // check self.denomination_asset_id exists
    dig 1
    ==
    // smart_contracts/base_d_asa/contract.py:186-189
    // # The reference implementation settlement asset is the denomination asset
    // assert (
    //     settlement_asset_id == self.denomination_asset_id
    // ), err.INVALID_SETTLEMENT_ASSET
    assert // Different settlement asset not supported, must be equal to denomination asset
    // smart_contracts/base_d_asa/contract.py:193
    // self.settlement_asset_id = settlement_asset_id
    bytec 10 // "settlement_asset_id"
    swap
    app_global_put
    // smart_contracts/base_d_asa/contract.py:194-200
    // # The reference implementation has on-chain settlement with ASA
    // itxn.AssetTransfer(
    //     xfer_asset=self.settlement_asset_id,
    //     asset_receiver=Global.current_application_address,
    //     asset_amount=0,
    //     fee=Global.min_txn_fee,
    // ).submit()
    itxn_begin
    // smart_contracts/base_d_asa/contract.py:199
    // fee=Global.min_txn_fee,
    global MinTxnFee
    // smart_contracts/base_d_asa/contract.py:196
    // xfer_asset=self.settlement_asset_id,
    intc_0 // 0
    bytec 10 // "settlement_asset_id"
    app_global_get_ex
    assert // check self.settlement_asset_id exists
    // smart_contracts/base_d_asa/contract.py:197
    // asset_receiver=Global.current_application_address,
    global CurrentApplicationAddress
    // smart_contracts/base_d_asa/contract.py:198
    // asset_amount=0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/base_d_asa/contract.py:194-195
    // # The reference implementation has on-chain settlement with ASA
    // itxn.AssetTransfer(
    intc_3 // axfer
    itxn_field TypeEnum
    itxn_field Fee
    // smart_contracts/base_d_asa/contract.py:194-200
    // # The reference implementation has on-chain settlement with ASA
    // itxn.AssetTransfer(
    //     xfer_asset=self.settlement_asset_id,
    //     asset_receiver=Global.current_application_address,
    //     asset_amount=0,
    //     fee=Global.min_txn_fee,
    // ).submit()
    itxn_submit
    // smart_contracts/base_d_asa/contract.py:532
    // principal.native % minimum_denomination.native == 0
    frame_dig -7
    btoi
    frame_dig -6
    btoi
    dup2
    %
    !
    // smart_contracts/base_d_asa/contract.py:530-533
    // # Set Principal and Minimum Denomination
    // assert (
    //     principal.native % minimum_denomination.native == 0
    // ), err.INVALID_MINIMUM_DENOMINATION
    assert // Minimum denomination is not a divisor of principal
    // smart_contracts/base_d_asa/contract.py:534
    // self.unit_value = minimum_denomination.native
    bytec 4 // "unit_value"
    dig 1
    app_global_put
    // smart_contracts/base_d_asa/contract.py:535
    // self.total_units = principal.native // minimum_denomination.native
    /
    bytec 5 // "total_units"
    swap
    app_global_put
    // smart_contracts/base_d_asa/contract.py:537-538
    // # Set Day-Count Convention
    // self.assert_day_count_convention(day_count_convention.native)
    frame_dig -5
    btoi
    dup
    frame_bury 1
    // smart_contracts/base_d_asa/contract.py:204-208
    // # The reference implementation supports only the Actual/Actual and Continuous day-count conventions
    // assert day_count_convention in (
    //     UInt64(cst.DCC_A_A),
    //     UInt64(cst.DCC_CONT),
    // ), err.INVALID_DAY_COUNT_CONVENTION
    bz asset_config_bool_true@16
    frame_dig 1
    // smart_contracts/base_d_asa/contract.py:207
    // UInt64(cst.DCC_CONT),
    pushint 255 // 255
    // smart_contracts/base_d_asa/contract.py:204-208
    // # The reference implementation supports only the Actual/Actual and Continuous day-count conventions
    // assert day_count_convention in (
    //     UInt64(cst.DCC_A_A),
    //     UInt64(cst.DCC_CONT),
    // ), err.INVALID_DAY_COUNT_CONVENTION
    ==
    bz asset_config_bool_false@17

asset_config_bool_true@16:
    intc_1 // 1

asset_config_bool_merge@18:
    // smart_contracts/base_d_asa/contract.py:204-208
    // # The reference implementation supports only the Actual/Actual and Continuous day-count conventions
    // assert day_count_convention in (
    //     UInt64(cst.DCC_A_A),
    //     UInt64(cst.DCC_CONT),
    // ), err.INVALID_DAY_COUNT_CONVENTION
    assert // Invalid day-count convention ID
    // smart_contracts/base_d_asa/contract.py:212
    // self.day_count_convention = day_count_convention
    bytec 11 // "day_count_convention"
    frame_dig 1
    app_global_put
    // smart_contracts/base_d_asa/contract.py:541-542
    // # Set Interest Rate
    // self.assert_interest_rate(interest_rate.native)
    frame_dig -4
    btoi
    // smart_contracts/base_d_asa/contract.py:216
    // assert interest_rate > UInt64(0), err.INVALID_INTEREST_RATE
    dup
    assert // Interest rate is not properly defined
    // smart_contracts/base_d_asa/contract.py:220
    // self.interest_rate = interest_rate
    bytec 20 // "interest_rate"
    swap
    app_global_put
    // smart_contracts/base_d_asa/contract.py:224
    // assert not coupon_rates.length, err.INVALID_COUPON_RATES
    frame_dig -3
    intc_0 // 0
    extract_uint16
    dup
    !
    assert // Coupon rates are not properly defined
    // smart_contracts/base_d_asa/contract.py:228
    // self.total_coupons = coupon_rates.length
    bytec 6 // "total_coupons"
    swap
    app_global_put
    // smart_contracts/base_d_asa/contract.py:229
    // if self.total_coupons:
    intc_0 // 0
    bytec 6 // "total_coupons"
    app_global_get_ex
    assert // check self.total_coupons exists
    bz asset_config_after_if_else@30
    // smart_contracts/base_d_asa/contract.py:230
    // self.coupon_rates.value = coupon_rates.copy()
    bytec 27 // 0x636f75706f6e5261746573
    box_del
    pop
    bytec 27 // 0x636f75706f6e5261746573
    frame_dig -3
    box_put

asset_config_after_if_else@30:
    // smart_contracts/base_d_asa/contract.py:235
    // time_events.length == self.total_coupons + cfg.TIME_SCHEDULE_LIMITS
    frame_dig -2
    intc_0 // 0
    extract_uint16
    intc_0 // 0
    bytec 6 // "total_coupons"
    app_global_get_ex
    assert // check self.total_coupons exists
    intc_3 // 4
    +
    ==
    // smart_contracts/base_d_asa/contract.py:234-236
    // assert (
    //     time_events.length == self.total_coupons + cfg.TIME_SCHEDULE_LIMITS
    // ), err.INVALID_TIME_EVENTS_LENGTH
    assert // Time events length is invalid
    // smart_contracts/base_d_asa/contract.py:551
    // self.assert_time_events_sorted(time_events)
    frame_dig -2
    callsub assert_time_events_sorted
    frame_bury -2
    // smart_contracts/base_d_asa/contract.py:260
    // self.time_events.value = time_events.copy()
    bytec 21 // 0x74696d654576656e7473
    box_del
    pop
    bytec 21 // 0x74696d654576656e7473
    frame_dig -2
    box_put
    // smart_contracts/base_d_asa/contract.py:261-263
    // self.primary_distribution_opening_date = time_events[
    //     cfg.PRIMARY_DISTRIBUTION_OPENING_DATE_IDX
    // ].native
    frame_dig -2
    extract 2 0
    dup
    frame_bury 0
    dup
    extract 0 8 // on error: Index access is out of bounds
    btoi
    // smart_contracts/base_d_asa/contract.py:261
    // self.primary_distribution_opening_date = time_events[
    bytec 12 // "primary_distribution_opening_date"
    // smart_contracts/base_d_asa/contract.py:261-263
    // self.primary_distribution_opening_date = time_events[
    //     cfg.PRIMARY_DISTRIBUTION_OPENING_DATE_IDX
    // ].native
    swap
    app_global_put
    // smart_contracts/base_d_asa/contract.py:264-266
    // self.primary_distribution_closure_date = time_events[
    //     cfg.PRIMARY_DISTRIBUTION_CLOSURE_DATE_IDX
    // ].native
    dup
    extract 8 8 // on error: Index access is out of bounds
    btoi
    // smart_contracts/base_d_asa/contract.py:264
    // self.primary_distribution_closure_date = time_events[
    bytec 13 // "primary_distribution_closure_date"
    // smart_contracts/base_d_asa/contract.py:264-266
    // self.primary_distribution_closure_date = time_events[
    //     cfg.PRIMARY_DISTRIBUTION_CLOSURE_DATE_IDX
    // ].native
    swap
    app_global_put
    // smart_contracts/base_d_asa/contract.py:267
    // self.issuance_date = time_events[cfg.ISSUANCE_DATE_IDX].native
    extract 16 8 // on error: Index access is out of bounds
    btoi
    bytec 14 // "issuance_date"
    swap
    app_global_put
    // smart_contracts/base_d_asa/contract.py:269-270
    // # Some D-ASA may not have a maturity date (e.g., perpetuals)
    // if time_events.length == self.total_coupons + cfg.TIME_SCHEDULE_LIMITS:
    frame_dig -2
    intc_0 // 0
    extract_uint16
    dup
    frame_bury 2
    intc_0 // 0
    bytec 6 // "total_coupons"
    app_global_get_ex
    assert // check self.total_coupons exists
    intc_3 // 4
    +
    ==
    bz asset_config_after_if_else@36
    // smart_contracts/base_d_asa/contract.py:271
    // self.maturity_date = time_events[cfg.MATURITY_DATE_IDX].native
    frame_dig 2
    intc_1 // 1
    -
    intc_2 // 8
    *
    frame_dig 0
    swap
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    bytec_3 // "maturity_date"
    swap
    app_global_put

asset_config_after_if_else@36:
    // smart_contracts/base_d_asa/contract.py:275
    // assert not time_periods.length, err.INVALID_TIME_PERIODS
    frame_dig -1
    intc_0 // 0
    extract_uint16
    !
    assert // Time periods are not properly defined
    // smart_contracts/base_d_asa/contract.py:558
    // self.status = UInt64(cfg.STATUS_ACTIVE)
    bytec_2 // "status"
    pushint 100 // 100
    app_global_put
    retsub

asset_config_bool_false@17:
    intc_0 // 0
    b asset_config_bool_merge@18

asset_config_bool_false@4:
    intc_0 // 0
    b asset_config_bool_merge@5


// smart_contracts.base_d_asa.contract.BaseDAsa.assert_caller_is_arranger() -> void:
assert_caller_is_arranger:
    // smart_contracts/base_d_asa/contract.py:115-116
    // @subroutine
    // def assert_caller_is_arranger(self) -> None:
    proto 0 0
    // smart_contracts/base_d_asa/contract.py:117
    // assert Txn.sender == self.arranger.value, err.UNAUTHORIZED
    txn Sender
    intc_0 // 0
    bytec 8 // 0x52323023
    app_global_get_ex
    assert // check self.arranger exists
    ==
    assert // Not authorized
    retsub


// smart_contracts.base_d_asa.contract.BaseDAsa.assert_time_events_sorted(time_events: bytes) -> bytes:
assert_time_events_sorted:
    // smart_contracts/base_d_asa/contract.py:238-239
    // @subroutine
    // def assert_time_events_sorted(self, time_events: typ.TimeEvents) -> None:
    proto 1 1
    pushbytes ""
    dup
    // smart_contracts/base_d_asa/contract.py:241
    // time_events[cfg.PRIMARY_DISTRIBUTION_OPENING_DATE_IDX].native
    frame_dig -1
    extract 2 0
    dup
    extract 0 8 // on error: Index access is out of bounds
    btoi
    // smart_contracts/base_d_asa/contract.py:242
    // > Global.latest_timestamp
    global LatestTimestamp
    // smart_contracts/base_d_asa/contract.py:241-242
    // time_events[cfg.PRIMARY_DISTRIBUTION_OPENING_DATE_IDX].native
    // > Global.latest_timestamp
    >
    // smart_contracts/base_d_asa/contract.py:240-243
    // assert (
    //     time_events[cfg.PRIMARY_DISTRIBUTION_OPENING_DATE_IDX].native
    //     > Global.latest_timestamp
    // ), err.INVALID_TIME
    assert // Time events must be set in the future
    // smart_contracts/base_d_asa/contract.py:244
    // for _t in urange(time_events.length - 1):
    frame_dig -1
    intc_0 // 0
    extract_uint16
    intc_1 // 1
    -
    intc_0 // 0

assert_time_events_sorted_for_header@1:
    // smart_contracts/base_d_asa/contract.py:244
    // for _t in urange(time_events.length - 1):
    frame_dig 4
    frame_dig 3
    <
    bz assert_time_events_sorted_after_for@6

assert_time_events_sorted_while_top@8:
    pushint 75 // 75
    global OpcodeBudget
    >
    bz assert_time_events_sorted_after_while@14
    itxn_begin
    pushint 6 // appl
    itxn_field TypeEnum
    pushint 5 // DeleteApplication
    itxn_field OnCompletion
    bytec 28 // 0x068101
    itxn_field ApprovalProgram
    bytec 28 // 0x068101
    itxn_field ClearStateProgram
    global MinTxnFee
    itxn_field Fee
    itxn_submit
    b assert_time_events_sorted_while_top@8

assert_time_events_sorted_after_while@14:
    // smart_contracts/base_d_asa/contract.py:249
    // time_i = time_events[_t].native
    frame_dig 4
    dup
    intc_2 // 8
    *
    frame_dig 2
    dup
    cover 3
    swap
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    dup
    cover 3
    frame_bury 1
    // smart_contracts/base_d_asa/contract.py:250
    // time_f = time_events[_t + 1].native
    intc_1 // 1
    +
    dup
    frame_bury 4
    intc_2 // 8
    *
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    dup
    frame_bury 0
    // smart_contracts/base_d_asa/contract.py:251
    // assert time_f > time_i, err.INVALID_SORTING
    <
    assert // Time events must be sorted in strictly ascending order
    // smart_contracts/base_d_asa/contract.py:252
    // if self.day_count_convention != UInt64(cst.DCC_CONT):
    intc_0 // 0
    bytec 11 // "day_count_convention"
    app_global_get_ex
    assert // check self.day_count_convention exists
    pushint 255 // 255
    !=
    bz assert_time_events_sorted_for_header@1
    // smart_contracts/base_d_asa/contract.py:253-254
    // # The reference implementation requires time periods expressed in days for regular day-count conventions
    // assert (time_f - time_i) % UInt64(
    frame_dig 0
    frame_dig 1
    -
    // smart_contracts/base_d_asa/contract.py:253-256
    // # The reference implementation requires time periods expressed in days for regular day-count conventions
    // assert (time_f - time_i) % UInt64(
    //     cst.DAY_2_SEC
    // ) == 0, err.INVALID_TIME_PERIOD
    pushint 86400 // 86400
    %
    !
    assert // Time periods in Actual/Actual day count convention must be multiples of a day (in seconds)
    b assert_time_events_sorted_for_header@1

assert_time_events_sorted_after_for@6:
    frame_dig -1
    frame_bury 0
    retsub


// smart_contracts.base_d_asa.contract.BaseDAsa.set_secondary_time_events(secondary_market_time_events: bytes) -> bytes:
set_secondary_time_events:
    // smart_contracts/base_d_asa/contract.py:560-563
    // @arc4.abimethod
    // def set_secondary_time_events(
    //     self, secondary_market_time_events: typ.TimeEvents
    // ) -> typ.SecondaryMarketSchedule:
    proto 1 1
    intc_0 // 0
    // smart_contracts/base_d_asa/contract.py:581
    // self.assert_caller_is_arranger()
    callsub assert_caller_is_arranger
    // smart_contracts/base_d_asa/contract.py:105
    // return self.status == cfg.STATUS_ENDED
    intc_0 // 0
    bytec_2 // "status"
    app_global_get_ex
    assert // check self.status exists
    intc 4 // 200
    ==
    // smart_contracts/base_d_asa/contract.py:582
    // assert not self.status_is_ended(), err.UNAUTHORIZED
    !
    assert // Not authorized
    // smart_contracts/base_d_asa/contract.py:583
    // self.assert_is_not_defaulted()
    callsub assert_is_not_defaulted
    // smart_contracts/base_d_asa/contract.py:585
    // assert secondary_market_time_events.length >= 1, err.INVALID_TIME_EVENTS_LENGTH
    frame_dig -1
    intc_0 // 0
    extract_uint16
    dup
    assert // Time events length is invalid
    // smart_contracts/base_d_asa/contract.py:586
    // if secondary_market_time_events.length > 1:
    intc_1 // 1
    >
    frame_dig -1
    swap
    bz set_secondary_time_events_after_if_else@2
    // smart_contracts/base_d_asa/contract.py:587
    // self.assert_time_events_sorted(secondary_market_time_events)
    frame_dig -1
    callsub assert_time_events_sorted
    dup
    frame_bury -1
    frame_bury 1

set_secondary_time_events_after_if_else@2:
    frame_dig 1
    frame_bury -1
    // smart_contracts/base_d_asa/contract.py:589
    // self.issuance_date
    intc_0 // 0
    bytec 14 // "issuance_date"
    app_global_get_ex
    assert // check self.issuance_date exists
    // smart_contracts/base_d_asa/contract.py:590-592
    // <= secondary_market_time_events[
    //     cfg.SECONDARY_MARKET_OPENING_DATE_IDX
    // ].native
    frame_dig -1
    extract 2 0
    dup
    frame_bury 0
    extract 0 8 // on error: Index access is out of bounds
    btoi
    // smart_contracts/base_d_asa/contract.py:589-592
    // self.issuance_date
    // <= secondary_market_time_events[
    //     cfg.SECONDARY_MARKET_OPENING_DATE_IDX
    // ].native
    swap
    dig 1
    <=
    // smart_contracts/base_d_asa/contract.py:588-593
    // assert (
    //     self.issuance_date
    //     <= secondary_market_time_events[
    //         cfg.SECONDARY_MARKET_OPENING_DATE_IDX
    //     ].native
    // ), err.INVALID_SECONDARY_OPENING_DATE
    assert // Invalid secondary market opening date
    // smart_contracts/base_d_asa/contract.py:594
    // self.secondary_market_opening_date = secondary_market_time_events[
    bytec 15 // "secondary_market_opening_date"
    // smart_contracts/base_d_asa/contract.py:594-596
    // self.secondary_market_opening_date = secondary_market_time_events[
    //     cfg.SECONDARY_MARKET_OPENING_DATE_IDX
    // ].native
    swap
    app_global_put
    // smart_contracts/base_d_asa/contract.py:597
    // if self.maturity_date:
    intc_0 // 0
    bytec_3 // "maturity_date"
    app_global_get_ex
    assert // check self.maturity_date exists
    bz set_secondary_time_events_after_if_else@4
    // smart_contracts/base_d_asa/contract.py:599
    // self.maturity_date
    intc_0 // 0
    bytec_3 // "maturity_date"
    app_global_get_ex
    assert // check self.maturity_date exists
    // smart_contracts/base_d_asa/contract.py:601
    // cfg.SECONDARY_MARKET_CLOSURE_DATE_IDX
    frame_dig -1
    intc_0 // 0
    extract_uint16
    // smart_contracts/base_d_asa/contract.py:600-602
    // >= secondary_market_time_events[
    //     cfg.SECONDARY_MARKET_CLOSURE_DATE_IDX
    // ].native
    intc_1 // 1
    -
    intc_2 // 8
    *
    frame_dig 0
    swap
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    // smart_contracts/base_d_asa/contract.py:599-602
    // self.maturity_date
    // >= secondary_market_time_events[
    //     cfg.SECONDARY_MARKET_CLOSURE_DATE_IDX
    // ].native
    swap
    dig 1
    >=
    // smart_contracts/base_d_asa/contract.py:598-603
    // assert (
    //     self.maturity_date
    //     >= secondary_market_time_events[
    //         cfg.SECONDARY_MARKET_CLOSURE_DATE_IDX
    //     ].native
    // ), err.INVALID_SECONDARY_CLOSURE_DATE
    assert // Invalid secondary market closure date
    // smart_contracts/base_d_asa/contract.py:604
    // self.secondary_market_closure_date = secondary_market_time_events[
    bytec 16 // "secondary_market_closure_date"
    // smart_contracts/base_d_asa/contract.py:604-606
    // self.secondary_market_closure_date = secondary_market_time_events[
    //     cfg.SECONDARY_MARKET_CLOSURE_DATE_IDX
    // ].native
    swap
    app_global_put

set_secondary_time_events_after_if_else@4:
    // smart_contracts/base_d_asa/contract.py:609
    // self.secondary_market_opening_date
    intc_0 // 0
    bytec 15 // "secondary_market_opening_date"
    app_global_get_ex
    assert // check self.secondary_market_opening_date exists
    // smart_contracts/base_d_asa/contract.py:608-610
    // secondary_market_opening_date=arc4.UInt64(
    //     self.secondary_market_opening_date
    // ),
    itob
    // smart_contracts/base_d_asa/contract.py:612
    // self.secondary_market_closure_date
    intc_0 // 0
    bytec 16 // "secondary_market_closure_date"
    app_global_get_ex
    assert // check self.secondary_market_closure_date exists
    // smart_contracts/base_d_asa/contract.py:611-613
    // secondary_market_closure_date=arc4.UInt64(
    //     self.secondary_market_closure_date
    // ),
    itob
    // smart_contracts/base_d_asa/contract.py:607-614
    // return typ.SecondaryMarketSchedule(
    //     secondary_market_opening_date=arc4.UInt64(
    //         self.secondary_market_opening_date
    //     ),
    //     secondary_market_closure_date=arc4.UInt64(
    //         self.secondary_market_closure_date
    //     ),
    // )
    concat
    frame_bury 0
    retsub


// smart_contracts.base_d_asa.contract.BaseDAsa.assert_is_not_defaulted() -> void:
assert_is_not_defaulted:
    // smart_contracts/base_d_asa/contract.py:107-108
    // @subroutine
    // def assert_is_not_defaulted(self) -> None:
    proto 0 0
    // smart_contracts/base_d_asa/contract.py:109
    // assert not self.defaulted, err.DEFAULTED
    intc_0 // 0
    bytec 18 // "defaulted"
    app_global_get_ex
    assert // check self.defaulted exists
    !
    assert // Defaulted
    retsub


// smart_contracts.base_d_asa.contract.BaseDAsa.assign_role(role_address: bytes, role: bytes, config: bytes) -> bytes:
assign_role:
    // smart_contracts/base_d_asa/contract.py:616-619
    // @arc4.abimethod
    // def assign_role(
    //     self, role_address: arc4.Address, role: arc4.UInt8, config: arc4.DynamicBytes
    // ) -> arc4.UInt64:
    proto 3 1
    // smart_contracts/base_d_asa/contract.py:637
    // self.assert_caller_is_arranger()
    callsub assert_caller_is_arranger
    // smart_contracts/base_d_asa/contract.py:638
    // self.assert_is_not_defaulted()
    callsub assert_is_not_defaulted
    // smart_contracts/base_d_asa/contract.py:639
    // assert role.native in (
    frame_dig -2
    btoi
    dup
    // smart_contracts/base_d_asa/contract.py:640
    // UInt64(cst.ROLE_ARRANGER),
    pushint 20 // 20
    // smart_contracts/base_d_asa/contract.py:639-646
    // assert role.native in (
    //     UInt64(cst.ROLE_ARRANGER),
    //     UInt64(cst.ROLE_ACCOUNT_MANAGER),
    //     UInt64(cst.ROLE_PRIMARY_DEALER),
    //     UInt64(cst.ROLE_TRUSTEE),
    //     UInt64(cst.ROLE_AUTHORITY),
    //     UInt64(cst.ROLE_INTEREST_ORACLE),
    // ), err.INVALID_ROLE
    ==
    bnz assign_role_bool_true@6
    frame_dig 0
    // smart_contracts/base_d_asa/contract.py:641
    // UInt64(cst.ROLE_ACCOUNT_MANAGER),
    pushint 40 // 40
    // smart_contracts/base_d_asa/contract.py:639-646
    // assert role.native in (
    //     UInt64(cst.ROLE_ARRANGER),
    //     UInt64(cst.ROLE_ACCOUNT_MANAGER),
    //     UInt64(cst.ROLE_PRIMARY_DEALER),
    //     UInt64(cst.ROLE_TRUSTEE),
    //     UInt64(cst.ROLE_AUTHORITY),
    //     UInt64(cst.ROLE_INTEREST_ORACLE),
    // ), err.INVALID_ROLE
    ==
    bnz assign_role_bool_true@6
    frame_dig 0
    // smart_contracts/base_d_asa/contract.py:642
    // UInt64(cst.ROLE_PRIMARY_DEALER),
    pushint 50 // 50
    // smart_contracts/base_d_asa/contract.py:639-646
    // assert role.native in (
    //     UInt64(cst.ROLE_ARRANGER),
    //     UInt64(cst.ROLE_ACCOUNT_MANAGER),
    //     UInt64(cst.ROLE_PRIMARY_DEALER),
    //     UInt64(cst.ROLE_TRUSTEE),
    //     UInt64(cst.ROLE_AUTHORITY),
    //     UInt64(cst.ROLE_INTEREST_ORACLE),
    // ), err.INVALID_ROLE
    ==
    bnz assign_role_bool_true@6
    frame_dig 0
    // smart_contracts/base_d_asa/contract.py:643
    // UInt64(cst.ROLE_TRUSTEE),
    pushint 60 // 60
    // smart_contracts/base_d_asa/contract.py:639-646
    // assert role.native in (
    //     UInt64(cst.ROLE_ARRANGER),
    //     UInt64(cst.ROLE_ACCOUNT_MANAGER),
    //     UInt64(cst.ROLE_PRIMARY_DEALER),
    //     UInt64(cst.ROLE_TRUSTEE),
    //     UInt64(cst.ROLE_AUTHORITY),
    //     UInt64(cst.ROLE_INTEREST_ORACLE),
    // ), err.INVALID_ROLE
    ==
    bnz assign_role_bool_true@6
    frame_dig 0
    // smart_contracts/base_d_asa/contract.py:644
    // UInt64(cst.ROLE_AUTHORITY),
    pushint 70 // 70
    // smart_contracts/base_d_asa/contract.py:639-646
    // assert role.native in (
    //     UInt64(cst.ROLE_ARRANGER),
    //     UInt64(cst.ROLE_ACCOUNT_MANAGER),
    //     UInt64(cst.ROLE_PRIMARY_DEALER),
    //     UInt64(cst.ROLE_TRUSTEE),
    //     UInt64(cst.ROLE_AUTHORITY),
    //     UInt64(cst.ROLE_INTEREST_ORACLE),
    // ), err.INVALID_ROLE
    ==
    bnz assign_role_bool_true@6
    frame_dig 0
    // smart_contracts/base_d_asa/contract.py:645
    // UInt64(cst.ROLE_INTEREST_ORACLE),
    pushint 80 // 80
    // smart_contracts/base_d_asa/contract.py:639-646
    // assert role.native in (
    //     UInt64(cst.ROLE_ARRANGER),
    //     UInt64(cst.ROLE_ACCOUNT_MANAGER),
    //     UInt64(cst.ROLE_PRIMARY_DEALER),
    //     UInt64(cst.ROLE_TRUSTEE),
    //     UInt64(cst.ROLE_AUTHORITY),
    //     UInt64(cst.ROLE_INTEREST_ORACLE),
    // ), err.INVALID_ROLE
    ==
    bz assign_role_bool_false@7

assign_role_bool_true@6:
    intc_1 // 1

assign_role_bool_merge@8:
    // smart_contracts/base_d_asa/contract.py:639-646
    // assert role.native in (
    //     UInt64(cst.ROLE_ARRANGER),
    //     UInt64(cst.ROLE_ACCOUNT_MANAGER),
    //     UInt64(cst.ROLE_PRIMARY_DEALER),
    //     UInt64(cst.ROLE_TRUSTEE),
    //     UInt64(cst.ROLE_AUTHORITY),
    //     UInt64(cst.ROLE_INTEREST_ORACLE),
    // ), err.INVALID_ROLE
    assert // Invalid role identifier
    // smart_contracts/base_d_asa/contract.py:648
    // case UInt64(cst.ROLE_ARRANGER):
    pushints 20 40 50 60 70 80 // 20, 40, 50, 60, 70, 80
    // smart_contracts/base_d_asa/contract.py:647-676
    // match role.native:
    //     case UInt64(cst.ROLE_ARRANGER):
    //         self.arranger.value = role_address.native
    //     case UInt64(cst.ROLE_ACCOUNT_MANAGER):
    //         assert (
    //             role_address not in self.account_manager
    //         ), err.INVALID_ROLE_ADDRESS
    //         self.account_manager[role_address] = typ.RoleConfig.from_bytes(
    //             config.native
    //         )
    //     case UInt64(cst.ROLE_PRIMARY_DEALER):
    //         assert role_address not in self.primary_dealer, err.INVALID_ROLE_ADDRESS
    //         self.primary_dealer[role_address] = typ.RoleConfig.from_bytes(
    //             config.native
    //         )
    //     case UInt64(cst.ROLE_TRUSTEE):
    //         assert role_address not in self.trustee, err.INVALID_ROLE_ADDRESS
    //         self.trustee[role_address] = typ.RoleConfig.from_bytes(config.native)
    //     case UInt64(cst.ROLE_AUTHORITY):
    //         assert role_address not in self.authority, err.INVALID_ROLE_ADDRESS
    //         self.authority[role_address] = typ.RoleConfig.from_bytes(config.native)
    //     case UInt64(cst.ROLE_INTEREST_ORACLE):
    //         assert (
    //             role_address not in self.interest_oracle
    //         ), err.INVALID_ROLE_ADDRESS
    //         self.interest_oracle[role_address] = typ.RoleConfig.from_bytes(
    //             config.native
    //         )
    //     case _:
    //         op.err()
    frame_dig 0
    match assign_role_switch_case_0@9 assign_role_switch_case_1@10 assign_role_switch_case_2@11 assign_role_switch_case_3@12 assign_role_switch_case_4@13 assign_role_switch_case_5@14
    // smart_contracts/base_d_asa/contract.py:676
    // op.err()
    err

assign_role_switch_case_5@14:
    // smart_contracts/base_d_asa/contract.py:670
    // role_address not in self.interest_oracle
    bytec 29 // 0x52383023
    frame_dig -3
    concat
    dup
    box_len
    bury 1
    !
    // smart_contracts/base_d_asa/contract.py:669-671
    // assert (
    //     role_address not in self.interest_oracle
    // ), err.INVALID_ROLE_ADDRESS
    assert // Invalid account role address
    // smart_contracts/base_d_asa/contract.py:673
    // config.native
    frame_dig -1
    extract 2 0
    // smart_contracts/base_d_asa/contract.py:672-674
    // self.interest_oracle[role_address] = typ.RoleConfig.from_bytes(
    //     config.native
    // )
    box_put

assign_role_switch_case_next@16:
    // smart_contracts/base_d_asa/contract.py:677
    // return arc4.UInt64(Global.latest_timestamp)
    global LatestTimestamp
    itob
    swap
    retsub

assign_role_switch_case_4@13:
    // smart_contracts/base_d_asa/contract.py:666
    // assert role_address not in self.authority, err.INVALID_ROLE_ADDRESS
    bytec 22 // 0x52373023
    frame_dig -3
    concat
    dup
    box_len
    bury 1
    !
    assert // Invalid account role address
    // smart_contracts/base_d_asa/contract.py:667
    // self.authority[role_address] = typ.RoleConfig.from_bytes(config.native)
    frame_dig -1
    extract 2 0
    box_put
    b assign_role_switch_case_next@16

assign_role_switch_case_3@12:
    // smart_contracts/base_d_asa/contract.py:663
    // assert role_address not in self.trustee, err.INVALID_ROLE_ADDRESS
    bytec 23 // 0x52363023
    frame_dig -3
    concat
    dup
    box_len
    bury 1
    !
    assert // Invalid account role address
    // smart_contracts/base_d_asa/contract.py:664
    // self.trustee[role_address] = typ.RoleConfig.from_bytes(config.native)
    frame_dig -1
    extract 2 0
    box_put
    b assign_role_switch_case_next@16

assign_role_switch_case_2@11:
    // smart_contracts/base_d_asa/contract.py:658
    // assert role_address not in self.primary_dealer, err.INVALID_ROLE_ADDRESS
    bytec 24 // 0x52353023
    frame_dig -3
    concat
    dup
    box_len
    bury 1
    !
    assert // Invalid account role address
    // smart_contracts/base_d_asa/contract.py:660
    // config.native
    frame_dig -1
    extract 2 0
    // smart_contracts/base_d_asa/contract.py:659-661
    // self.primary_dealer[role_address] = typ.RoleConfig.from_bytes(
    //     config.native
    // )
    box_put
    b assign_role_switch_case_next@16

assign_role_switch_case_1@10:
    // smart_contracts/base_d_asa/contract.py:652
    // role_address not in self.account_manager
    bytec 25 // 0x52343023
    frame_dig -3
    concat
    dup
    box_len
    bury 1
    !
    // smart_contracts/base_d_asa/contract.py:651-653
    // assert (
    //     role_address not in self.account_manager
    // ), err.INVALID_ROLE_ADDRESS
    assert // Invalid account role address
    // smart_contracts/base_d_asa/contract.py:655
    // config.native
    frame_dig -1
    extract 2 0
    // smart_contracts/base_d_asa/contract.py:654-656
    // self.account_manager[role_address] = typ.RoleConfig.from_bytes(
    //     config.native
    // )
    box_put
    b assign_role_switch_case_next@16

assign_role_switch_case_0@9:
    // smart_contracts/base_d_asa/contract.py:649
    // self.arranger.value = role_address.native
    bytec 8 // 0x52323023
    frame_dig -3
    app_global_put
    b assign_role_switch_case_next@16

assign_role_bool_false@7:
    intc_0 // 0
    b assign_role_bool_merge@8


// smart_contracts.base_d_asa.contract.BaseDAsa.revoke_role(role_address: bytes, role: bytes) -> bytes:
revoke_role:
    // smart_contracts/base_d_asa/contract.py:679-680
    // @arc4.abimethod
    // def revoke_role(self, role_address: arc4.Address, role: arc4.UInt8) -> arc4.UInt64:
    proto 2 1
    // smart_contracts/base_d_asa/contract.py:697
    // self.assert_caller_is_arranger()
    callsub assert_caller_is_arranger
    // smart_contracts/base_d_asa/contract.py:698
    // self.assert_is_not_defaulted()
    callsub assert_is_not_defaulted
    // smart_contracts/base_d_asa/contract.py:699
    // assert role.native in (
    frame_dig -1
    btoi
    dup
    // smart_contracts/base_d_asa/contract.py:700
    // UInt64(cst.ROLE_ACCOUNT_MANAGER),
    pushint 40 // 40
    // smart_contracts/base_d_asa/contract.py:699-705
    // assert role.native in (
    //     UInt64(cst.ROLE_ACCOUNT_MANAGER),
    //     UInt64(cst.ROLE_PRIMARY_DEALER),
    //     UInt64(cst.ROLE_TRUSTEE),
    //     UInt64(cst.ROLE_AUTHORITY),
    //     UInt64(cst.ROLE_INTEREST_ORACLE),
    // ), err.INVALID_ROLE
    ==
    bnz revoke_role_bool_true@5
    frame_dig 0
    // smart_contracts/base_d_asa/contract.py:701
    // UInt64(cst.ROLE_PRIMARY_DEALER),
    pushint 50 // 50
    // smart_contracts/base_d_asa/contract.py:699-705
    // assert role.native in (
    //     UInt64(cst.ROLE_ACCOUNT_MANAGER),
    //     UInt64(cst.ROLE_PRIMARY_DEALER),
    //     UInt64(cst.ROLE_TRUSTEE),
    //     UInt64(cst.ROLE_AUTHORITY),
    //     UInt64(cst.ROLE_INTEREST_ORACLE),
    // ), err.INVALID_ROLE
    ==
    bnz revoke_role_bool_true@5
    frame_dig 0
    // smart_contracts/base_d_asa/contract.py:702
    // UInt64(cst.ROLE_TRUSTEE),
    pushint 60 // 60
    // smart_contracts/base_d_asa/contract.py:699-705
    // assert role.native in (
    //     UInt64(cst.ROLE_ACCOUNT_MANAGER),
    //     UInt64(cst.ROLE_PRIMARY_DEALER),
    //     UInt64(cst.ROLE_TRUSTEE),
    //     UInt64(cst.ROLE_AUTHORITY),
    //     UInt64(cst.ROLE_INTEREST_ORACLE),
    // ), err.INVALID_ROLE
    ==
    bnz revoke_role_bool_true@5
    frame_dig 0
    // smart_contracts/base_d_asa/contract.py:703
    // UInt64(cst.ROLE_AUTHORITY),
    pushint 70 // 70
    // smart_contracts/base_d_asa/contract.py:699-705
    // assert role.native in (
    //     UInt64(cst.ROLE_ACCOUNT_MANAGER),
    //     UInt64(cst.ROLE_PRIMARY_DEALER),
    //     UInt64(cst.ROLE_TRUSTEE),
    //     UInt64(cst.ROLE_AUTHORITY),
    //     UInt64(cst.ROLE_INTEREST_ORACLE),
    // ), err.INVALID_ROLE
    ==
    bnz revoke_role_bool_true@5
    frame_dig 0
    // smart_contracts/base_d_asa/contract.py:704
    // UInt64(cst.ROLE_INTEREST_ORACLE),
    pushint 80 // 80
    // smart_contracts/base_d_asa/contract.py:699-705
    // assert role.native in (
    //     UInt64(cst.ROLE_ACCOUNT_MANAGER),
    //     UInt64(cst.ROLE_PRIMARY_DEALER),
    //     UInt64(cst.ROLE_TRUSTEE),
    //     UInt64(cst.ROLE_AUTHORITY),
    //     UInt64(cst.ROLE_INTEREST_ORACLE),
    // ), err.INVALID_ROLE
    ==
    bz revoke_role_bool_false@6

revoke_role_bool_true@5:
    intc_1 // 1

revoke_role_bool_merge@7:
    // smart_contracts/base_d_asa/contract.py:699-705
    // assert role.native in (
    //     UInt64(cst.ROLE_ACCOUNT_MANAGER),
    //     UInt64(cst.ROLE_PRIMARY_DEALER),
    //     UInt64(cst.ROLE_TRUSTEE),
    //     UInt64(cst.ROLE_AUTHORITY),
    //     UInt64(cst.ROLE_INTEREST_ORACLE),
    // ), err.INVALID_ROLE
    assert // Invalid role identifier
    // smart_contracts/base_d_asa/contract.py:707-708
    // # Arranger role can not be revoked (just rotated)
    // case UInt64(cst.ROLE_ACCOUNT_MANAGER):
    pushints 40 50 60 70 80 // 40, 50, 60, 70, 80
    // smart_contracts/base_d_asa/contract.py:706-724
    // match role.native:
    //     # Arranger role can not be revoked (just rotated)
    //     case UInt64(cst.ROLE_ACCOUNT_MANAGER):
    //         assert role_address in self.account_manager, err.INVALID_ROLE_ADDRESS
    //         op.Box.delete(cst.PREFIX_ID_ACCOUNT_MANAGER + role_address.bytes)
    //     case UInt64(cst.ROLE_PRIMARY_DEALER):
    //         assert role_address in self.primary_dealer, err.INVALID_ROLE_ADDRESS
    //         op.Box.delete(cst.PREFIX_ID_PRIMARY_DEALER + role_address.bytes)
    //     case UInt64(cst.ROLE_TRUSTEE):
    //         assert role_address in self.trustee, err.INVALID_ROLE_ADDRESS
    //         op.Box.delete(cst.PREFIX_ID_TRUSTEE + role_address.bytes)
    //     case UInt64(cst.ROLE_AUTHORITY):
    //         assert role_address in self.authority, err.INVALID_ROLE_ADDRESS
    //         op.Box.delete(cst.PREFIX_ID_AUTHORITY + role_address.bytes)
    //     case UInt64(cst.ROLE_INTEREST_ORACLE):
    //         assert role_address in self.interest_oracle, err.INVALID_ROLE_ADDRESS
    //         op.Box.delete(cst.PREFIX_ID_INTEREST_ORACLE + role_address.bytes)
    //     case _:
    //         op.err()
    frame_dig 0
    match revoke_role_switch_case_0@8 revoke_role_switch_case_1@9 revoke_role_switch_case_2@10 revoke_role_switch_case_3@11 revoke_role_switch_case_4@12
    // smart_contracts/base_d_asa/contract.py:724
    // op.err()
    err

revoke_role_switch_case_4@12:
    // smart_contracts/base_d_asa/contract.py:721
    // assert role_address in self.interest_oracle, err.INVALID_ROLE_ADDRESS
    bytec 29 // 0x52383023
    frame_dig -2
    concat
    dup
    box_len
    bury 1
    assert // Invalid account role address
    // smart_contracts/base_d_asa/contract.py:722
    // op.Box.delete(cst.PREFIX_ID_INTEREST_ORACLE + role_address.bytes)
    box_del
    pop

revoke_role_switch_case_next@14:
    // smart_contracts/base_d_asa/contract.py:725
    // return arc4.UInt64(Global.latest_timestamp)
    global LatestTimestamp
    itob
    swap
    retsub

revoke_role_switch_case_3@11:
    // smart_contracts/base_d_asa/contract.py:718
    // assert role_address in self.authority, err.INVALID_ROLE_ADDRESS
    bytec 22 // 0x52373023
    frame_dig -2
    concat
    dup
    box_len
    bury 1
    assert // Invalid account role address
    // smart_contracts/base_d_asa/contract.py:719
    // op.Box.delete(cst.PREFIX_ID_AUTHORITY + role_address.bytes)
    box_del
    pop
    b revoke_role_switch_case_next@14

revoke_role_switch_case_2@10:
    // smart_contracts/base_d_asa/contract.py:715
    // assert role_address in self.trustee, err.INVALID_ROLE_ADDRESS
    bytec 23 // 0x52363023
    frame_dig -2
    concat
    dup
    box_len
    bury 1
    assert // Invalid account role address
    // smart_contracts/base_d_asa/contract.py:716
    // op.Box.delete(cst.PREFIX_ID_TRUSTEE + role_address.bytes)
    box_del
    pop
    b revoke_role_switch_case_next@14

revoke_role_switch_case_1@9:
    // smart_contracts/base_d_asa/contract.py:712
    // assert role_address in self.primary_dealer, err.INVALID_ROLE_ADDRESS
    bytec 24 // 0x52353023
    frame_dig -2
    concat
    dup
    box_len
    bury 1
    assert // Invalid account role address
    // smart_contracts/base_d_asa/contract.py:713
    // op.Box.delete(cst.PREFIX_ID_PRIMARY_DEALER + role_address.bytes)
    box_del
    pop
    b revoke_role_switch_case_next@14

revoke_role_switch_case_0@8:
    // smart_contracts/base_d_asa/contract.py:709
    // assert role_address in self.account_manager, err.INVALID_ROLE_ADDRESS
    bytec 25 // 0x52343023
    frame_dig -2
    concat
    dup
    box_len
    bury 1
    assert // Invalid account role address
    // smart_contracts/base_d_asa/contract.py:710
    // op.Box.delete(cst.PREFIX_ID_ACCOUNT_MANAGER + role_address.bytes)
    box_del
    pop
    b revoke_role_switch_case_next@14

revoke_role_bool_false@6:
    intc_0 // 0
    b revoke_role_bool_merge@7


// smart_contracts.base_d_asa.contract.BaseDAsa.open_account(holding_address: bytes, payment_address: bytes) -> bytes:
open_account:
    // smart_contracts/base_d_asa/contract.py:727-730
    // @arc4.abimethod
    // def open_account(
    //     self, holding_address: arc4.Address, payment_address: arc4.Address
    // ) -> arc4.UInt64:
    proto 2 1
    // smart_contracts/base_d_asa/contract.py:747
    // self.assert_caller_is_account_manager()
    callsub assert_caller_is_account_manager
    // smart_contracts/base_d_asa/contract.py:105
    // return self.status == cfg.STATUS_ENDED
    intc_0 // 0
    bytec_2 // "status"
    app_global_get_ex
    assert // check self.status exists
    intc 4 // 200
    ==
    // smart_contracts/base_d_asa/contract.py:748
    // assert not self.status_is_ended(), err.UNAUTHORIZED
    !
    assert // Not authorized
    // smart_contracts/base_d_asa/contract.py:749
    // self.assert_is_not_defaulted()
    callsub assert_is_not_defaulted
    // smart_contracts/base_d_asa/contract.py:750
    // self.assert_is_not_suspended()
    callsub assert_is_not_suspended
    // smart_contracts/base_d_asa/contract.py:751
    // assert holding_address not in self.account, err.INVALID_HOLDING_ADDRESS
    bytec 7 // 0x52333023
    frame_dig -2
    concat
    dup
    box_len
    bury 1
    !
    assert // Invalid account holding address
    // smart_contracts/base_d_asa/contract.py:753-759
    // self.account[holding_address] = typ.AccountInfo(
    //     payment_address=payment_address,
    //     units=arc4.UInt64(),
    //     unit_value=arc4.UInt64(),
    //     paid_coupons=arc4.UInt64(),
    //     suspended=arc4.Bool(),
    // )
    frame_dig -1
    // smart_contracts/base_d_asa/contract.py:755
    // units=arc4.UInt64(),
    bytec 26 // 0x0000000000000000
    // smart_contracts/base_d_asa/contract.py:753-759
    // self.account[holding_address] = typ.AccountInfo(
    //     payment_address=payment_address,
    //     units=arc4.UInt64(),
    //     unit_value=arc4.UInt64(),
    //     paid_coupons=arc4.UInt64(),
    //     suspended=arc4.Bool(),
    // )
    concat
    // smart_contracts/base_d_asa/contract.py:756
    // unit_value=arc4.UInt64(),
    bytec 26 // 0x0000000000000000
    // smart_contracts/base_d_asa/contract.py:753-759
    // self.account[holding_address] = typ.AccountInfo(
    //     payment_address=payment_address,
    //     units=arc4.UInt64(),
    //     unit_value=arc4.UInt64(),
    //     paid_coupons=arc4.UInt64(),
    //     suspended=arc4.Bool(),
    // )
    concat
    // smart_contracts/base_d_asa/contract.py:757
    // paid_coupons=arc4.UInt64(),
    bytec 26 // 0x0000000000000000
    // smart_contracts/base_d_asa/contract.py:753-759
    // self.account[holding_address] = typ.AccountInfo(
    //     payment_address=payment_address,
    //     units=arc4.UInt64(),
    //     unit_value=arc4.UInt64(),
    //     paid_coupons=arc4.UInt64(),
    //     suspended=arc4.Bool(),
    // )
    concat
    // smart_contracts/base_d_asa/contract.py:758
    // suspended=arc4.Bool(),
    pushbytes 0x00
    // smart_contracts/base_d_asa/contract.py:753-759
    // self.account[holding_address] = typ.AccountInfo(
    //     payment_address=payment_address,
    //     units=arc4.UInt64(),
    //     unit_value=arc4.UInt64(),
    //     paid_coupons=arc4.UInt64(),
    //     suspended=arc4.Bool(),
    // )
    concat
    box_put
    // smart_contracts/base_d_asa/contract.py:760
    // return arc4.UInt64(Global.latest_timestamp)
    global LatestTimestamp
    itob
    retsub


// smart_contracts.base_d_asa.contract.BaseDAsa.assert_caller_is_account_manager() -> void:
assert_caller_is_account_manager:
    // smart_contracts/base_d_asa/contract.py:119-120
    // @subroutine
    // def assert_caller_is_account_manager(self) -> None:
    proto 0 0
    intc_0 // 0
    // smart_contracts/base_d_asa/contract.py:123
    // caller in self.account_manager
    bytec 25 // 0x52343023
    // smart_contracts/base_d_asa/contract.py:121
    // caller = arc4.Address(Txn.sender)
    txn Sender
    // smart_contracts/base_d_asa/contract.py:123
    // caller in self.account_manager
    concat
    dup
    box_len
    bury 1
    // smart_contracts/base_d_asa/contract.py:123-126
    // caller in self.account_manager
    // and self.account_manager[caller].role_validity_start
    // <= Global.latest_timestamp
    // <= self.account_manager[caller].role_validity_end
    bz assert_caller_is_account_manager_bool_false@4
    // smart_contracts/base_d_asa/contract.py:124
    // and self.account_manager[caller].role_validity_start
    frame_dig 1
    box_get
    assert // check self.account_manager entry exists
    extract 0 8 // on error: Index access is out of bounds
    // smart_contracts/base_d_asa/contract.py:125
    // <= Global.latest_timestamp
    global LatestTimestamp
    // smart_contracts/base_d_asa/contract.py:124-125
    // and self.account_manager[caller].role_validity_start
    // <= Global.latest_timestamp
    itob
    dup
    frame_bury 0
    b<=
    // smart_contracts/base_d_asa/contract.py:124-126
    // and self.account_manager[caller].role_validity_start
    // <= Global.latest_timestamp
    // <= self.account_manager[caller].role_validity_end
    bz assert_caller_is_account_manager_bool_false@4
    // smart_contracts/base_d_asa/contract.py:126
    // <= self.account_manager[caller].role_validity_end
    frame_dig 1
    box_get
    assert // check self.account_manager entry exists
    extract 8 8 // on error: Index access is out of bounds
    // smart_contracts/base_d_asa/contract.py:125-126
    // <= Global.latest_timestamp
    // <= self.account_manager[caller].role_validity_end
    frame_dig 0
    b>=
    // smart_contracts/base_d_asa/contract.py:124-126
    // and self.account_manager[caller].role_validity_start
    // <= Global.latest_timestamp
    // <= self.account_manager[caller].role_validity_end
    bz assert_caller_is_account_manager_bool_false@4
    intc_1 // 1

assert_caller_is_account_manager_bool_merge@5:
    // smart_contracts/base_d_asa/contract.py:122-127
    // assert (
    //     caller in self.account_manager
    //     and self.account_manager[caller].role_validity_start
    //     <= Global.latest_timestamp
    //     <= self.account_manager[caller].role_validity_end
    // ), err.UNAUTHORIZED
    assert // Not authorized
    retsub

assert_caller_is_account_manager_bool_false@4:
    intc_0 // 0
    b assert_caller_is_account_manager_bool_merge@5


// smart_contracts.base_d_asa.contract.BaseDAsa.assert_is_not_suspended() -> void:
assert_is_not_suspended:
    // smart_contracts/base_d_asa/contract.py:111-112
    // @subroutine
    // def assert_is_not_suspended(self) -> None:
    proto 0 0
    // smart_contracts/base_d_asa/contract.py:113
    // assert not self.suspended, err.SUSPENDED
    intc_0 // 0
    bytec 17 // "suspended"
    app_global_get_ex
    assert // check self.suspended exists
    !
    assert // Suspended operations
    retsub


// smart_contracts.base_d_asa.contract.BaseDAsa.close_account(holding_address: bytes) -> bytes:
close_account:
    // smart_contracts/base_d_asa/contract.py:762-765
    // @arc4.abimethod
    // def close_account(
    //     self, holding_address: arc4.Address
    // ) -> arc4.Tuple[arc4.UInt64, arc4.UInt64]:
    proto 1 1
    // smart_contracts/base_d_asa/contract.py:780
    // self.assert_caller_is_account_manager()
    callsub assert_caller_is_account_manager
    // smart_contracts/base_d_asa/contract.py:781
    // self.assert_is_not_defaulted()
    callsub assert_is_not_defaulted
    // smart_contracts/base_d_asa/contract.py:171
    // assert holding_address in self.account, err.INVALID_HOLDING_ADDRESS
    bytec 7 // 0x52333023
    frame_dig -1
    concat
    dup
    box_len
    bury 1
    assert // Invalid account holding address
    // smart_contracts/base_d_asa/contract.py:784
    // closed_units = self.account[holding_address].units.native
    dup
    box_get
    assert // check self.account entry exists
    extract 32 8 // on error: Index access is out of bounds
    btoi
    dup
    uncover 2
    // smart_contracts/base_d_asa/contract.py:785
    // op.Box.delete(cst.PREFIX_ID_ACCOUNT + holding_address.bytes)
    box_del
    pop
    // smart_contracts/base_d_asa/contract.py:786
    // self.circulating_units -= closed_units
    intc_0 // 0
    bytec_1 // "circulating_units"
    app_global_get_ex
    assert // check self.circulating_units exists
    swap
    -
    bytec_1 // "circulating_units"
    swap
    app_global_put
    // smart_contracts/base_d_asa/contract.py:361
    // if self.circulating_units == 0:
    intc_0 // 0
    bytec_1 // "circulating_units"
    app_global_get_ex
    assert // check self.circulating_units exists
    bnz close_account_after_if_else@3
    // smart_contracts/base_d_asa/contract.py:362
    // self.status = UInt64(cfg.STATUS_ENDED)
    bytec_2 // "status"
    intc 4 // 200
    app_global_put

close_account_after_if_else@3:
    // smart_contracts/base_d_asa/contract.py:789
    // (arc4.UInt64(closed_units), arc4.UInt64(Global.latest_timestamp))
    frame_dig 0
    itob
    global LatestTimestamp
    itob
    // smart_contracts/base_d_asa/contract.py:788-790
    // return arc4.Tuple(
    //     (arc4.UInt64(closed_units), arc4.UInt64(Global.latest_timestamp))
    // )
    concat
    swap
    retsub


// smart_contracts.base_d_asa.contract.BaseDAsa.primary_distribution(holding_address: bytes, units: bytes) -> bytes:
primary_distribution:
    // smart_contracts/base_d_asa/contract.py:792-795
    // @arc4.abimethod
    // def primary_distribution(
    //     self, holding_address: arc4.Address, units: arc4.UInt64
    // ) -> arc4.UInt64:
    proto 2 1
    intc_0 // 0
    dup
    pushbytes ""
    // smart_contracts/base_d_asa/contract.py:101
    // return self.status == cfg.STATUS_ACTIVE
    intc_0 // 0
    bytec_2 // "status"
    app_global_get_ex
    assert // check self.status exists
    pushint 100 // 100
    ==
    // smart_contracts/base_d_asa/contract.py:284-287
    // self.status_is_active()
    // and self.primary_distribution_opening_date
    // <= Global.latest_timestamp
    // < self.primary_distribution_closure_date
    bz primary_distribution_bool_false@5
    // smart_contracts/base_d_asa/contract.py:285
    // and self.primary_distribution_opening_date
    intc_0 // 0
    bytec 12 // "primary_distribution_opening_date"
    app_global_get_ex
    assert // check self.primary_distribution_opening_date exists
    // smart_contracts/base_d_asa/contract.py:286
    // <= Global.latest_timestamp
    global LatestTimestamp
    dup
    frame_bury 2
    // smart_contracts/base_d_asa/contract.py:285-286
    // and self.primary_distribution_opening_date
    // <= Global.latest_timestamp
    <=
    // smart_contracts/base_d_asa/contract.py:285-287
    // and self.primary_distribution_opening_date
    // <= Global.latest_timestamp
    // < self.primary_distribution_closure_date
    bz primary_distribution_bool_false@5
    // smart_contracts/base_d_asa/contract.py:287
    // < self.primary_distribution_closure_date
    intc_0 // 0
    bytec 13 // "primary_distribution_closure_date"
    app_global_get_ex
    assert // check self.primary_distribution_closure_date exists
    // smart_contracts/base_d_asa/contract.py:286-287
    // <= Global.latest_timestamp
    // < self.primary_distribution_closure_date
    frame_dig 2
    >
    // smart_contracts/base_d_asa/contract.py:285-287
    // and self.primary_distribution_opening_date
    // <= Global.latest_timestamp
    // < self.primary_distribution_closure_date
    bz primary_distribution_bool_false@5
    intc_1 // 1

primary_distribution_bool_merge@6:
    // smart_contracts/base_d_asa/contract.py:283-288
    // assert (
    //     self.status_is_active()
    //     and self.primary_distribution_opening_date
    //     <= Global.latest_timestamp
    //     < self.primary_distribution_closure_date
    // ), err.PRIMARY_DISTRIBUTION_CLOSED
    assert // Primary distribution is closed
    // smart_contracts/base_d_asa/contract.py:133
    // caller in self.primary_dealer
    bytec 24 // 0x52353023
    // smart_contracts/base_d_asa/contract.py:131
    // caller = arc4.Address(Txn.sender)
    txn Sender
    // smart_contracts/base_d_asa/contract.py:133
    // caller in self.primary_dealer
    concat
    dup
    frame_bury 0
    box_len
    bury 1
    // smart_contracts/base_d_asa/contract.py:133-136
    // caller in self.primary_dealer
    // and self.primary_dealer[caller].role_validity_start
    // <= Global.latest_timestamp
    // <= self.primary_dealer[caller].role_validity_end
    bz primary_distribution_bool_false@12
    // smart_contracts/base_d_asa/contract.py:134
    // and self.primary_dealer[caller].role_validity_start
    frame_dig 0
    box_get
    assert // check self.primary_dealer entry exists
    extract 0 8 // on error: Index access is out of bounds
    // smart_contracts/base_d_asa/contract.py:135
    // <= Global.latest_timestamp
    global LatestTimestamp
    // smart_contracts/base_d_asa/contract.py:134-135
    // and self.primary_dealer[caller].role_validity_start
    // <= Global.latest_timestamp
    itob
    dup
    frame_bury 1
    b<=
    // smart_contracts/base_d_asa/contract.py:134-136
    // and self.primary_dealer[caller].role_validity_start
    // <= Global.latest_timestamp
    // <= self.primary_dealer[caller].role_validity_end
    bz primary_distribution_bool_false@12
    // smart_contracts/base_d_asa/contract.py:136
    // <= self.primary_dealer[caller].role_validity_end
    frame_dig 0
    box_get
    assert // check self.primary_dealer entry exists
    extract 8 8 // on error: Index access is out of bounds
    // smart_contracts/base_d_asa/contract.py:135-136
    // <= Global.latest_timestamp
    // <= self.primary_dealer[caller].role_validity_end
    frame_dig 1
    b>=
    // smart_contracts/base_d_asa/contract.py:134-136
    // and self.primary_dealer[caller].role_validity_start
    // <= Global.latest_timestamp
    // <= self.primary_dealer[caller].role_validity_end
    bz primary_distribution_bool_false@12
    intc_1 // 1

primary_distribution_bool_merge@13:
    // smart_contracts/base_d_asa/contract.py:132-137
    // assert (
    //     caller in self.primary_dealer
    //     and self.primary_dealer[caller].role_validity_start
    //     <= Global.latest_timestamp
    //     <= self.primary_dealer[caller].role_validity_end
    // ), err.UNAUTHORIZED
    assert // Not authorized
    // smart_contracts/base_d_asa/contract.py:171
    // assert holding_address in self.account, err.INVALID_HOLDING_ADDRESS
    bytec 7 // 0x52333023
    frame_dig -2
    concat
    dup
    box_len
    bury 1
    assert // Invalid account holding address
    // smart_contracts/base_d_asa/contract.py:820
    // self.assert_is_not_defaulted()
    callsub assert_is_not_defaulted
    // smart_contracts/base_d_asa/contract.py:821
    // self.assert_is_not_suspended()
    callsub assert_is_not_suspended
    // smart_contracts/base_d_asa/contract.py:822
    // assert units.native > 0, err.ZERO_UNITS
    frame_dig -1
    btoi
    dup
    assert // Can not distribute zero units
    // smart_contracts/base_d_asa/contract.py:824
    // self.circulating_units + units.native <= self.total_units
    intc_0 // 0
    bytec_1 // "circulating_units"
    app_global_get_ex
    assert // check self.circulating_units exists
    dig 1
    +
    intc_0 // 0
    bytec 5 // "total_units"
    app_global_get_ex
    assert // check self.total_units exists
    <=
    // smart_contracts/base_d_asa/contract.py:823-825
    // assert (
    //     self.circulating_units + units.native <= self.total_units
    // ), err.OVER_DISTRIBUTION
    assert // Insufficient remaining D-ASA units
    // smart_contracts/base_d_asa/contract.py:827
    // self.circulating_units += units.native
    intc_0 // 0
    bytec_1 // "circulating_units"
    app_global_get_ex
    assert // check self.circulating_units exists
    dig 1
    +
    bytec_1 // "circulating_units"
    swap
    app_global_put
    // smart_contracts/base_d_asa/contract.py:829
    // self.account[holding_address].units.native + units.native
    dig 1
    box_get
    assert // check self.account entry exists
    extract 32 8 // on error: Index access is out of bounds
    btoi
    +
    // smart_contracts/base_d_asa/contract.py:828-830
    // self.account[holding_address].units = arc4.UInt64(
    //     self.account[holding_address].units.native + units.native
    // )
    itob
    // smart_contracts/base_d_asa/contract.py:828
    // self.account[holding_address].units = arc4.UInt64(
    dig 1
    box_get
    assert // check self.account entry exists
    // smart_contracts/base_d_asa/contract.py:828-830
    // self.account[holding_address].units = arc4.UInt64(
    //     self.account[holding_address].units.native + units.native
    // )
    swap
    replace2 32
    dig 1
    swap
    box_put
    // smart_contracts/base_d_asa/contract.py:831
    // self.account[holding_address].unit_value = arc4.UInt64(self.unit_value)
    intc_0 // 0
    bytec 4 // "unit_value"
    app_global_get_ex
    assert // check self.unit_value exists
    itob
    dig 1
    box_get
    assert // check self.account entry exists
    swap
    replace2 40
    box_put
    // smart_contracts/base_d_asa/contract.py:832
    // return arc4.UInt64(self.total_units - self.circulating_units)
    intc_0 // 0
    bytec 5 // "total_units"
    app_global_get_ex
    assert // check self.total_units exists
    intc_0 // 0
    bytec_1 // "circulating_units"
    app_global_get_ex
    assert // check self.circulating_units exists
    -
    itob
    frame_bury 0
    retsub

primary_distribution_bool_false@12:
    intc_0 // 0
    b primary_distribution_bool_merge@13

primary_distribution_bool_false@5:
    intc_0 // 0
    b primary_distribution_bool_merge@6


// smart_contracts.base_d_asa.contract.BaseDAsa.set_asset_suspension(suspended: bytes) -> bytes:
set_asset_suspension:
    // smart_contracts/base_d_asa/contract.py:834-835
    // @arc4.abimethod
    // def set_asset_suspension(self, suspended: arc4.Bool) -> arc4.UInt64:
    proto 1 1
    // smart_contracts/base_d_asa/contract.py:848
    // self.assert_caller_is_authority()
    callsub assert_caller_is_authority
    // smart_contracts/base_d_asa/contract.py:849
    // self.suspended = UInt64(suspended.native)
    frame_dig -1
    intc_0 // 0
    getbit
    bytec 17 // "suspended"
    swap
    app_global_put
    // smart_contracts/base_d_asa/contract.py:850
    // return arc4.UInt64(Global.latest_timestamp)
    global LatestTimestamp
    itob
    retsub


// smart_contracts.base_d_asa.contract.BaseDAsa.assert_caller_is_authority() -> void:
assert_caller_is_authority:
    // smart_contracts/base_d_asa/contract.py:149-150
    // @subroutine
    // def assert_caller_is_authority(self) -> None:
    proto 0 0
    intc_0 // 0
    // smart_contracts/base_d_asa/contract.py:153
    // caller in self.authority
    bytec 22 // 0x52373023
    // smart_contracts/base_d_asa/contract.py:151
    // caller = arc4.Address(Txn.sender)
    txn Sender
    // smart_contracts/base_d_asa/contract.py:153
    // caller in self.authority
    concat
    dup
    box_len
    bury 1
    // smart_contracts/base_d_asa/contract.py:153-156
    // caller in self.authority
    // and self.authority[caller].role_validity_start
    // <= Global.latest_timestamp
    // <= self.authority[caller].role_validity_end
    bz assert_caller_is_authority_bool_false@4
    // smart_contracts/base_d_asa/contract.py:154
    // and self.authority[caller].role_validity_start
    frame_dig 1
    box_get
    assert // check self.authority entry exists
    extract 0 8 // on error: Index access is out of bounds
    // smart_contracts/base_d_asa/contract.py:155
    // <= Global.latest_timestamp
    global LatestTimestamp
    // smart_contracts/base_d_asa/contract.py:154-155
    // and self.authority[caller].role_validity_start
    // <= Global.latest_timestamp
    itob
    dup
    frame_bury 0
    b<=
    // smart_contracts/base_d_asa/contract.py:154-156
    // and self.authority[caller].role_validity_start
    // <= Global.latest_timestamp
    // <= self.authority[caller].role_validity_end
    bz assert_caller_is_authority_bool_false@4
    // smart_contracts/base_d_asa/contract.py:156
    // <= self.authority[caller].role_validity_end
    frame_dig 1
    box_get
    assert // check self.authority entry exists
    extract 8 8 // on error: Index access is out of bounds
    // smart_contracts/base_d_asa/contract.py:155-156
    // <= Global.latest_timestamp
    // <= self.authority[caller].role_validity_end
    frame_dig 0
    b>=
    // smart_contracts/base_d_asa/contract.py:154-156
    // and self.authority[caller].role_validity_start
    // <= Global.latest_timestamp
    // <= self.authority[caller].role_validity_end
    bz assert_caller_is_authority_bool_false@4
    intc_1 // 1

assert_caller_is_authority_bool_merge@5:
    // smart_contracts/base_d_asa/contract.py:152-157
    // assert (
    //     caller in self.authority
    //     and self.authority[caller].role_validity_start
    //     <= Global.latest_timestamp
    //     <= self.authority[caller].role_validity_end
    // ), err.UNAUTHORIZED
    assert // Not authorized
    retsub

assert_caller_is_authority_bool_false@4:
    intc_0 // 0
    b assert_caller_is_authority_bool_merge@5


// smart_contracts.base_d_asa.contract.BaseDAsa.set_account_suspension(holding_address: bytes, suspended: bytes) -> bytes:
set_account_suspension:
    // smart_contracts/base_d_asa/contract.py:852-855
    // @arc4.abimethod
    // def set_account_suspension(
    //     self, holding_address: arc4.Address, suspended: arc4.Bool
    // ) -> arc4.UInt64:
    proto 2 1
    // smart_contracts/base_d_asa/contract.py:870
    // self.assert_caller_is_authority()
    callsub assert_caller_is_authority
    // smart_contracts/base_d_asa/contract.py:171
    // assert holding_address in self.account, err.INVALID_HOLDING_ADDRESS
    bytec 7 // 0x52333023
    frame_dig -2
    concat
    dup
    box_len
    bury 1
    assert // Invalid account holding address
    // smart_contracts/base_d_asa/contract.py:872
    // self.account[holding_address].suspended = suspended
    dup
    box_get
    assert // check self.account entry exists
    frame_dig -1
    intc_0 // 0
    getbit
    pushint 448 // 448
    swap
    setbit
    box_put
    // smart_contracts/base_d_asa/contract.py:873
    // return arc4.UInt64(Global.latest_timestamp)
    global LatestTimestamp
    itob
    retsub


// smart_contracts.base_d_asa.contract.BaseDAsa.set_default_status(defaulted: bytes) -> void:
set_default_status:
    // smart_contracts/base_d_asa/contract.py:875-876
    // @arc4.abimethod
    // def set_default_status(self, defaulted: arc4.Bool) -> None:
    proto 1 0
    intc_0 // 0
    // smart_contracts/base_d_asa/contract.py:143
    // caller in self.trustee
    bytec 23 // 0x52363023
    // smart_contracts/base_d_asa/contract.py:141
    // caller = arc4.Address(Txn.sender)
    txn Sender
    // smart_contracts/base_d_asa/contract.py:143
    // caller in self.trustee
    concat
    dup
    box_len
    bury 1
    // smart_contracts/base_d_asa/contract.py:143-146
    // caller in self.trustee
    // and self.trustee[caller].role_validity_start
    // <= Global.latest_timestamp
    // <= self.trustee[caller].role_validity_end
    bz set_default_status_bool_false@5
    // smart_contracts/base_d_asa/contract.py:144
    // and self.trustee[caller].role_validity_start
    frame_dig 1
    box_get
    assert // check self.trustee entry exists
    extract 0 8 // on error: Index access is out of bounds
    // smart_contracts/base_d_asa/contract.py:145
    // <= Global.latest_timestamp
    global LatestTimestamp
    // smart_contracts/base_d_asa/contract.py:144-145
    // and self.trustee[caller].role_validity_start
    // <= Global.latest_timestamp
    itob
    dup
    frame_bury 0
    b<=
    // smart_contracts/base_d_asa/contract.py:144-146
    // and self.trustee[caller].role_validity_start
    // <= Global.latest_timestamp
    // <= self.trustee[caller].role_validity_end
    bz set_default_status_bool_false@5
    // smart_contracts/base_d_asa/contract.py:146
    // <= self.trustee[caller].role_validity_end
    frame_dig 1
    box_get
    assert // check self.trustee entry exists
    extract 8 8 // on error: Index access is out of bounds
    // smart_contracts/base_d_asa/contract.py:145-146
    // <= Global.latest_timestamp
    // <= self.trustee[caller].role_validity_end
    frame_dig 0
    b>=
    // smart_contracts/base_d_asa/contract.py:144-146
    // and self.trustee[caller].role_validity_start
    // <= Global.latest_timestamp
    // <= self.trustee[caller].role_validity_end
    bz set_default_status_bool_false@5
    intc_1 // 1

set_default_status_bool_merge@6:
    // smart_contracts/base_d_asa/contract.py:142-147
    // assert (
    //     caller in self.trustee
    //     and self.trustee[caller].role_validity_start
    //     <= Global.latest_timestamp
    //     <= self.trustee[caller].role_validity_end
    // ), err.UNAUTHORIZED
    assert // Not authorized
    // smart_contracts/base_d_asa/contract.py:887
    // self.defaulted = UInt64(defaulted.native)
    frame_dig -1
    intc_0 // 0
    getbit
    bytec 18 // "defaulted"
    swap
    app_global_put
    retsub

set_default_status_bool_false@5:
    intc_0 // 0
    b set_default_status_bool_merge@6


// smart_contracts.base_d_asa.contract.BaseDAsa.get_asset_info() -> bytes:
get_asset_info:
    // smart_contracts/base_d_asa/contract.py:889-890
    // @arc4.abimethod(readonly=True)
    // def get_asset_info(self) -> typ.AssetInfo:
    proto 0 1
    // smart_contracts/base_d_asa/contract.py:899
    // performance = UInt64(cst.PRF_PERFORMANT)
    intc_0 // 0
    dup
    // smart_contracts/base_d_asa/contract.py:900
    // if Global.latest_timestamp > self.maturity_date > 0:
    global LatestTimestamp
    intc_0 // 0
    bytec_3 // "maturity_date"
    app_global_get_ex
    swap
    dup
    cover 2
    cover 4
    assert // check self.maturity_date exists
    >
    bz get_asset_info_after_if_else@3
    frame_dig 0
    frame_bury 2
    frame_dig 1
    bz get_asset_info_after_if_else@3
    // smart_contracts/base_d_asa/contract.py:901
    // performance = UInt64(cst.PRF_MATURED)
    intc_3 // 4
    frame_bury 2

get_asset_info_after_if_else@3:
    frame_dig 2
    frame_bury 0
    // smart_contracts/base_d_asa/contract.py:902-903
    // # The reference implementation has no grace or delinquency periods
    // if self.defaulted:
    intc_0 // 0
    bytec 18 // "defaulted"
    app_global_get_ex
    assert // check self.defaulted exists
    bz get_asset_info_after_if_else@5
    // smart_contracts/base_d_asa/contract.py:904
    // performance = UInt64(cst.PRF_DEFAULTED)
    pushint 3 // 3
    frame_bury 0

get_asset_info_after_if_else@5:
    // smart_contracts/base_d_asa/contract.py:907
    // denomination_asset_id=arc4.UInt64(self.denomination_asset_id),
    intc_0 // 0
    bytec 9 // "denomination_asset_id"
    app_global_get_ex
    assert // check self.denomination_asset_id exists
    itob
    // smart_contracts/base_d_asa/contract.py:908
    // settlement_asset_id=arc4.UInt64(self.settlement_asset_id),
    intc_0 // 0
    bytec 10 // "settlement_asset_id"
    app_global_get_ex
    assert // check self.settlement_asset_id exists
    itob
    // smart_contracts/base_d_asa/contract.py:335
    // return self.circulating_units * self.unit_value
    intc_0 // 0
    bytec_1 // "circulating_units"
    app_global_get_ex
    assert // check self.circulating_units exists
    intc_0 // 0
    bytec 4 // "unit_value"
    app_global_get_ex
    assert // check self.unit_value exists
    *
    // smart_contracts/base_d_asa/contract.py:909
    // outstanding_principal=arc4.UInt64(self.outstanding_principal()),
    itob
    // smart_contracts/base_d_asa/contract.py:910
    // unit_value=arc4.UInt64(self.unit_value),
    intc_0 // 0
    bytec 4 // "unit_value"
    app_global_get_ex
    assert // check self.unit_value exists
    itob
    // smart_contracts/base_d_asa/contract.py:911
    // day_count_convention=arc4.UInt8(self.day_count_convention),
    intc_0 // 0
    bytec 11 // "day_count_convention"
    app_global_get_ex
    assert // check self.day_count_convention exists
    itob
    extract 7 1
    // smart_contracts/base_d_asa/contract.py:912
    // interest_rate=arc4.UInt16(self.interest_rate),
    intc_0 // 0
    bytec 20 // "interest_rate"
    app_global_get_ex
    assert // check self.interest_rate exists
    itob
    extract 6 2
    // smart_contracts/base_d_asa/contract.py:913
    // total_supply=arc4.UInt64(self.total_units),
    intc_0 // 0
    bytec 5 // "total_units"
    app_global_get_ex
    assert // check self.total_units exists
    itob
    // smart_contracts/base_d_asa/contract.py:914
    // circulating_supply=arc4.UInt64(self.circulating_units),
    intc_0 // 0
    bytec_1 // "circulating_units"
    app_global_get_ex
    assert // check self.circulating_units exists
    itob
    // smart_contracts/base_d_asa/contract.py:916
    // self.primary_distribution_opening_date
    intc_0 // 0
    bytec 12 // "primary_distribution_opening_date"
    app_global_get_ex
    assert // check self.primary_distribution_opening_date exists
    // smart_contracts/base_d_asa/contract.py:915-917
    // primary_distribution_opening_date=arc4.UInt64(
    //     self.primary_distribution_opening_date
    // ),
    itob
    // smart_contracts/base_d_asa/contract.py:919
    // self.primary_distribution_closure_date
    intc_0 // 0
    bytec 13 // "primary_distribution_closure_date"
    app_global_get_ex
    assert // check self.primary_distribution_closure_date exists
    // smart_contracts/base_d_asa/contract.py:918-920
    // primary_distribution_closure_date=arc4.UInt64(
    //     self.primary_distribution_closure_date
    // ),
    itob
    // smart_contracts/base_d_asa/contract.py:921
    // issuance_date=arc4.UInt64(self.issuance_date),
    intc_0 // 0
    bytec 14 // "issuance_date"
    app_global_get_ex
    assert // check self.issuance_date exists
    itob
    // smart_contracts/base_d_asa/contract.py:922
    // maturity_date=arc4.UInt64(self.maturity_date),
    intc_0 // 0
    bytec_3 // "maturity_date"
    app_global_get_ex
    assert // check self.maturity_date exists
    itob
    // smart_contracts/base_d_asa/contract.py:923
    // suspended=arc4.Bool(bool(self.suspended)),
    intc_0 // 0
    bytec 17 // "suspended"
    app_global_get_ex
    assert // check self.suspended exists
    pushbytes 0x00
    intc_0 // 0
    uncover 2
    setbit
    // smart_contracts/base_d_asa/contract.py:924
    // performance=arc4.UInt8(performance),
    frame_dig 0
    itob
    extract 7 1
    // smart_contracts/base_d_asa/contract.py:906-925
    // return typ.AssetInfo(
    //     denomination_asset_id=arc4.UInt64(self.denomination_asset_id),
    //     settlement_asset_id=arc4.UInt64(self.settlement_asset_id),
    //     outstanding_principal=arc4.UInt64(self.outstanding_principal()),
    //     unit_value=arc4.UInt64(self.unit_value),
    //     day_count_convention=arc4.UInt8(self.day_count_convention),
    //     interest_rate=arc4.UInt16(self.interest_rate),
    //     total_supply=arc4.UInt64(self.total_units),
    //     circulating_supply=arc4.UInt64(self.circulating_units),
    //     primary_distribution_opening_date=arc4.UInt64(
    //         self.primary_distribution_opening_date
    //     ),
    //     primary_distribution_closure_date=arc4.UInt64(
    //         self.primary_distribution_closure_date
    //     ),
    //     issuance_date=arc4.UInt64(self.issuance_date),
    //     maturity_date=arc4.UInt64(self.maturity_date),
    //     suspended=arc4.Bool(bool(self.suspended)),
    //     performance=arc4.UInt8(performance),
    // )
    uncover 13
    uncover 13
    concat
    uncover 12
    concat
    uncover 11
    concat
    uncover 10
    concat
    uncover 9
    concat
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    frame_bury 0
    retsub


// smart_contracts.base_d_asa.contract.BaseDAsa.get_account_info(holding_address: bytes) -> bytes:
get_account_info:
    // smart_contracts/base_d_asa/contract.py:927-928
    // @arc4.abimethod(readonly=True)
    // def get_account_info(self, holding_address: arc4.Address) -> typ.AccountInfo:
    proto 1 1
    // smart_contracts/base_d_asa/contract.py:171
    // assert holding_address in self.account, err.INVALID_HOLDING_ADDRESS
    bytec 7 // 0x52333023
    frame_dig -1
    concat
    dup
    box_len
    bury 1
    assert // Invalid account holding address
    // smart_contracts/base_d_asa/contract.py:942
    // return self.account[holding_address]
    box_get
    assert // check self.account entry exists
    retsub


// smart_contracts.base_d_asa.contract.BaseDAsa.get_time_events() -> bytes:
get_time_events:
    // smart_contracts/base_d_asa/contract.py:944-945
    // @arc4.abimethod(readonly=True)
    // def get_time_events(self) -> typ.TimeEvents:
    proto 0 1
    // smart_contracts/base_d_asa/contract.py:952
    // time_events = typ.TimeEvents()
    pushbytes 0x0000
    // smart_contracts/base_d_asa/contract.py:101
    // return self.status == cfg.STATUS_ACTIVE
    intc_0 // 0
    bytec_2 // "status"
    app_global_get_ex
    assert // check self.status exists
    pushint 100 // 100
    ==
    // smart_contracts/base_d_asa/contract.py:953
    // if self.status_is_active():
    bz get_time_events_after_if_else@2
    // smart_contracts/base_d_asa/contract.py:954
    // time_events = self.time_events.value.copy()
    bytec 21 // 0x74696d654576656e7473
    box_get
    swap
    frame_bury 0
    assert // check self.time_events exists

get_time_events_after_if_else@2:
    // smart_contracts/base_d_asa/contract.py:955
    // return time_events
    frame_dig 0
    swap
    retsub


// smart_contracts.base_d_asa.contract.BaseDAsa.get_secondary_market_schedule() -> bytes:
get_secondary_market_schedule:
    // smart_contracts/base_d_asa/contract.py:957-958
    // @arc4.abimethod(readonly=True)
    // def get_secondary_market_schedule(self) -> typ.TimeEvents:
    proto 0 1
    // smart_contracts/base_d_asa/contract.py:966
    // arc4.UInt64(self.secondary_market_opening_date),
    intc_0 // 0
    bytec 15 // "secondary_market_opening_date"
    app_global_get_ex
    assert // check self.secondary_market_opening_date exists
    itob
    // smart_contracts/base_d_asa/contract.py:967
    // arc4.UInt64(self.secondary_market_closure_date),
    intc_0 // 0
    bytec 16 // "secondary_market_closure_date"
    app_global_get_ex
    assert // check self.secondary_market_closure_date exists
    itob
    // smart_contracts/base_d_asa/contract.py:965-968
    // return typ.TimeEvents(
    //     arc4.UInt64(self.secondary_market_opening_date),
    //     arc4.UInt64(self.secondary_market_closure_date),
    // )
    concat
    pushbytes 0x0002
    swap
    concat
    retsub


// smart_contracts.base_d_asa.contract.BaseDAsa.get_asset_metadata() -> bytes:
get_asset_metadata:
    // smart_contracts/base_d_asa/contract.py:970-971
    // @arc4.abimethod(readonly=True)
    // def get_asset_metadata(self) -> typ.AssetMetadata:
    proto 0 1
    // smart_contracts/base_d_asa/contract.py:979
    // return typ.AssetMetadata.from_bytes(self.metadata)
    intc_0 // 0
    bytec 19 // "metadata"
    app_global_get_ex
    assert // check self.metadata exists
    retsub


// smart_contracts.base_d_asa.contract.BaseDAsa.asset_update() -> void:
asset_update:
    // smart_contracts/base_d_asa/contract.py:468-469
    // @arc4.baremethod(allow_actions=["UpdateApplication"])
    // def asset_update(self) -> None:
    proto 0 0
    // smart_contracts/base_d_asa/contract.py:473-476
    // # The reference implementation grants the update permissions to the Arranger.
    // # Other implementations may disable D-ASA application updatability or change its authorizations.
    // # ⚠️ WARNING: Application updates must be executed VERY carefully, as they might introduce breaking changes.
    // self.assert_caller_is_arranger()
    callsub assert_caller_is_arranger
    retsub
