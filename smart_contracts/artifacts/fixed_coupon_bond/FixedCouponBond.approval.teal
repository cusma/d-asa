#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 1 32 8 448 255 200 86400
    bytecblock 0x151f7c75 0x52333023 "status" 0x "circulating_units" "total_coupons" "issuance_date" "maturity_date" "settlement_asset_id" "primary_distribution_opening_date" 0x74696d654576656e7473 "day_count_convention" "total_units" "secondary_market_opening_date" "secondary_market_closure_date" 0x636f75706f6e5261746573 0x52323023 "unit_value" "metadata" "principal_discount" "primary_distribution_closure_date" "suspended" "defaulted" "due_coupons_watermark" "paid_coupon_units" "denomination_asset_id" "interest_rate" 0x00 0x52373023 0x52363023 0x52353023 0x52343023 0x068101 0x0012 0x0000 0x52383023
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/base_d_asa/contract.py:40-41
    // # Role Based Access Control
    // self.arranger = GlobalState(Account(), key=cst.PREFIX_ID_ARRANGER)
    bytec 16 // 0x52323023
    global ZeroAddress
    app_global_put
    // smart_contracts/base_d_asa/contract.py:56-57
    // # Asset Configuration
    // self.denomination_asset_id = UInt64()
    bytec 25 // "denomination_asset_id"
    intc_0 // 0
    app_global_put
    // smart_contracts/base_d_asa/contract.py:58
    // self.settlement_asset_id = UInt64()
    bytec 8 // "settlement_asset_id"
    intc_0 // 0
    app_global_put
    // smart_contracts/base_d_asa/contract.py:59
    // self.unit_value = UInt64()
    bytec 17 // "unit_value"
    intc_0 // 0
    app_global_put
    // smart_contracts/base_d_asa/contract.py:60
    // self.day_count_convention = UInt64()
    bytec 11 // "day_count_convention"
    intc_0 // 0
    app_global_put
    // smart_contracts/base_d_asa/contract.py:62-63
    // # Metadata
    // self.metadata = Bytes()
    bytec 18 // "metadata"
    bytec_3 // 0x
    app_global_put
    // smart_contracts/base_d_asa/contract.py:65-66
    // # Supply
    // self.total_units = UInt64()
    bytec 12 // "total_units"
    intc_0 // 0
    app_global_put
    // smart_contracts/base_d_asa/contract.py:67
    // self.circulating_units = UInt64()
    bytec 4 // "circulating_units"
    intc_0 // 0
    app_global_put
    // smart_contracts/base_d_asa/contract.py:69-70
    // # Principal
    // self.principal_discount = UInt64()
    bytec 19 // "principal_discount"
    intc_0 // 0
    app_global_put
    // smart_contracts/base_d_asa/contract.py:72-73
    // # Interest
    // self.interest_rate = UInt64()
    bytec 26 // "interest_rate"
    intc_0 // 0
    app_global_put
    // smart_contracts/base_d_asa/contract.py:77
    // self.total_coupons = UInt64()
    bytec 5 // "total_coupons"
    intc_0 // 0
    app_global_put
    // smart_contracts/base_d_asa/contract.py:82
    // self.primary_distribution_opening_date = UInt64()
    bytec 9 // "primary_distribution_opening_date"
    intc_0 // 0
    app_global_put
    // smart_contracts/base_d_asa/contract.py:83
    // self.primary_distribution_closure_date = UInt64()
    bytec 20 // "primary_distribution_closure_date"
    intc_0 // 0
    app_global_put
    // smart_contracts/base_d_asa/contract.py:84
    // self.issuance_date = UInt64()
    bytec 6 // "issuance_date"
    intc_0 // 0
    app_global_put
    // smart_contracts/base_d_asa/contract.py:85
    // self.secondary_market_opening_date = UInt64()
    bytec 13 // "secondary_market_opening_date"
    intc_0 // 0
    app_global_put
    // smart_contracts/base_d_asa/contract.py:86
    // self.secondary_market_closure_date = UInt64()
    bytec 14 // "secondary_market_closure_date"
    intc_0 // 0
    app_global_put
    // smart_contracts/base_d_asa/contract.py:87
    // self.maturity_date = UInt64()
    bytec 7 // "maturity_date"
    intc_0 // 0
    app_global_put
    // smart_contracts/base_d_asa/contract.py:89-90
    // # Status
    // self.status = UInt64(cfg.STATUS_EMPTY)
    bytec_2 // "status"
    intc_0 // 0
    app_global_put
    // smart_contracts/base_d_asa/contract.py:91
    // self.suspended = False
    bytec 21 // "suspended"
    intc_0 // 0
    app_global_put
    // smart_contracts/base_d_asa/contract.py:92
    // self.defaulted = False
    bytec 22 // "defaulted"
    intc_0 // 0
    app_global_put
    // smart_contracts/fixed_coupon_bond/contract.py:37-38
    // # State schema validation
    // assert Txn.global_num_byte_slice == cfg.GLOBAL_BYTES, err.WRONG_GLOBAL_BYTES
    txn GlobalNumByteSlice
    pushint 2
    ==
    assert // Wrong Global Bytes allocation
    // smart_contracts/fixed_coupon_bond/contract.py:39
    // assert Txn.global_num_uint == cfg.GLOBAL_UINTS, err.WRONG_GLOBAL_UINTS
    txn GlobalNumUint
    pushint 20
    ==
    assert // Wrong Global UInts allocation
    // smart_contracts/fixed_coupon_bond/contract.py:40
    // assert Txn.local_num_byte_slice == cfg.LOCAL_BYTES, err.WRONG_LOCAL_BYTES
    txn LocalNumByteSlice
    !
    assert // Wrong Local Bytes allocation
    // smart_contracts/fixed_coupon_bond/contract.py:41
    // assert Txn.local_num_uint == cfg.LOCAL_UINTS, err.WRONG_LOCAL_UINTS
    txn LocalNumUint
    !
    assert // Wrong Local UInts allocation
    // smart_contracts/fixed_coupon_bond/contract.py:43-44
    // # Coupons
    // self.due_coupons_watermark = UInt64()
    bytec 23 // "due_coupons_watermark"
    intc_0 // 0
    app_global_put
    // smart_contracts/fixed_coupon_bond/contract.py:45
    // self.paid_coupon_units = UInt64()
    bytec 24 // "paid_coupon_units"
    intc_0 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/fixed_coupon_bond/contract.py:21-29
    // class FixedCouponBond(
    //     BaseDAsa,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    pushbytes 0x25dba95b // method "asset_update((uint8,uint8,uint8,uint8,uint8,uint8,byte[32],string))void"
    txna ApplicationArgs 0
    match main_asset_update_route@4

main_switch_case_next@5:
    // smart_contracts/fixed_coupon_bond/contract.py:21-29
    // class FixedCouponBond(
    //     BaseDAsa,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    txn OnCompletion
    !
    assert
    txn ApplicationID
    bz main_create_NoOp@30
    pushbytess 0x4fd6a3cc 0x8cf14b51 0x9c76b6a3 0x44363d49 0x53bef045 0x67db4f20 0xf6a96c8d 0x89474134 0x1d6fc255 0xfef74567 0xb8fc1390 0x3d43d1f0 0xebd96b2f 0x6c85e3ee 0xf63ace8d 0xbbcca18a 0x1a7babb4 0x402dba47 0xed02759f 0xfad2173e 0x08efea35 0xe4a5ab54 // method "asset_transfer(address,address,uint64)uint64", method "pay_coupon(address,byte[])(uint64,uint64,byte[])", method "pay_principal(address,byte[])(uint64,uint64,byte[])", method "get_account_units_current_value(address,uint64)(uint64,uint64,(uint64,uint64))", method "get_coupon_rates()uint16[]", method "get_payment_amount(address)(uint64,uint64)", method "get_coupons_status()(uint64,uint64,uint64,(uint64,uint64),bool)", method "asset_config(uint64,uint64,uint64,uint64,uint64,uint8,uint16,uint16[],uint64[],(uint64,uint64)[])void", method "set_secondary_time_events(uint64[])(uint64,uint64)", method "assign_role(address,uint8,byte[])uint64", method "revoke_role(address,uint8)uint64", method "open_account(address,address)uint64", method "close_account(address)(uint64,uint64)", method "primary_distribution(address,uint64)uint64", method "set_asset_suspension(bool)uint64", method "set_account_suspension(address,bool)uint64", method "set_default_status(bool)void", method "get_asset_info()(uint64,uint64,uint64,uint64,uint8,uint16,uint16,uint64,uint64,uint64,uint64,uint64,uint64,bool,uint8)", method "get_account_info(address)(address,uint64,uint64,uint64,bool)", method "get_time_events()uint64[]", method "get_secondary_market_schedule()uint64[]", method "get_asset_metadata()(uint8,uint8,uint8,uint8,uint8,uint8,byte[32],string)"
    txna ApplicationArgs 0
    match asset_transfer pay_coupon pay_principal get_account_units_current_value get_coupon_rates get_payment_amount get_coupons_status asset_config set_secondary_time_events assign_role revoke_role open_account close_account primary_distribution set_asset_suspension set_account_suspension set_default_status get_asset_info get_account_info get_time_events get_secondary_market_schedule get_asset_metadata
    err

main_create_NoOp@30:
    // smart_contracts/fixed_coupon_bond/contract.py:21-29
    // class FixedCouponBond(
    //     BaseDAsa,
    //     state_totals=StateTotals(
    //         global_bytes=cfg.GLOBAL_BYTES,
    //         global_uints=cfg.GLOBAL_UINTS,
    //         local_bytes=cfg.LOCAL_BYTES,
    //         local_uints=cfg.LOCAL_UINTS,
    //     ),
    // ):
    pushbytes 0x3f0efc6c // method "asset_create(address,(uint8,uint8,uint8,uint8,uint8,uint8,byte[32],string))void"
    txna ApplicationArgs 0
    match asset_create
    err

main_asset_update_route@4:
    // smart_contracts/base_d_asa/contract.py:412
    // @arc4.abimethod(allow_actions=["UpdateApplication"])
    txn OnCompletion
    pushint 4 // UpdateApplication
    ==
    txn ApplicationID
    &&
    assert
    b asset_update


// _puya_lib.util.ensure_budget(required_budget: uint64, fee_source: uint64) -> void:
ensure_budget:
    proto 2 0
    frame_dig -2
    pushint 10
    +

ensure_budget_while_top@1:
    frame_dig 0
    global OpcodeBudget
    >
    bz ensure_budget_after_while@6
    itxn_begin
    pushint 6 // appl
    itxn_field TypeEnum
    pushint 5 // DeleteApplication
    itxn_field OnCompletion
    bytec 32 // 0x068101
    itxn_field ApprovalProgram
    bytec 32 // 0x068101
    itxn_field ClearStateProgram
    frame_dig -1
    switch ensure_budget_switch_case_0@3 ensure_budget_switch_case_1@4

ensure_budget_switch_case_next@5:
    itxn_submit
    b ensure_budget_while_top@1

ensure_budget_switch_case_1@4:
    global MinTxnFee
    itxn_field Fee
    b ensure_budget_switch_case_next@5

ensure_budget_switch_case_0@3:
    intc_0 // 0
    itxn_field Fee
    b ensure_budget_switch_case_next@5

ensure_budget_after_while@6:
    retsub


// smart_contracts.fixed_coupon_bond.contract.FixedCouponBond.asset_transfer[routing]() -> void:
asset_transfer:
    intc_0 // 0
    dupn 2
    bytec_3 // ""
    dupn 2
    // smart_contracts/fixed_coupon_bond/contract.py:143
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 3
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/base_d_asa/contract.py:100
    // return self.status == cfg.STATUS_ACTIVE
    intc_0 // 0
    bytec_2 // "status"
    app_global_get_ex
    assert // check self.status exists
    pushint 100
    ==
    // smart_contracts/base_d_asa/contract.py:267-270
    // self.status_is_active()
    // and self.secondary_market_opening_date
    // <= Global.latest_timestamp
    // < self.secondary_market_closure_date
    bz asset_transfer_bool_false@5
    // smart_contracts/base_d_asa/contract.py:268
    // and self.secondary_market_opening_date
    intc_0 // 0
    bytec 13 // "secondary_market_opening_date"
    app_global_get_ex
    assert // check self.secondary_market_opening_date exists
    // smart_contracts/base_d_asa/contract.py:269
    // <= Global.latest_timestamp
    global LatestTimestamp
    dup
    bury 7
    // smart_contracts/base_d_asa/contract.py:268-269
    // and self.secondary_market_opening_date
    // <= Global.latest_timestamp
    <=
    // smart_contracts/base_d_asa/contract.py:268-270
    // and self.secondary_market_opening_date
    // <= Global.latest_timestamp
    // < self.secondary_market_closure_date
    bz asset_transfer_bool_false@5
    // smart_contracts/base_d_asa/contract.py:270
    // < self.secondary_market_closure_date
    intc_0 // 0
    bytec 14 // "secondary_market_closure_date"
    app_global_get_ex
    assert // check self.secondary_market_closure_date exists
    // smart_contracts/base_d_asa/contract.py:269-270
    // <= Global.latest_timestamp
    // < self.secondary_market_closure_date
    dig 5
    >
    // smart_contracts/base_d_asa/contract.py:268-270
    // and self.secondary_market_opening_date
    // <= Global.latest_timestamp
    // < self.secondary_market_closure_date
    bz asset_transfer_bool_false@5
    intc_1 // 1

asset_transfer_bool_merge@6:
    // smart_contracts/base_d_asa/contract.py:266-271
    // assert (
    //     self.status_is_active()
    //     and self.secondary_market_opening_date
    //     <= Global.latest_timestamp
    //     < self.secondary_market_closure_date
    // ), err.SECONDARY_MARKET_CLOSED
    assert // Secondary market is closed
    // smart_contracts/base_d_asa/contract.py:330-332
    // # The reference implementation grants transfer right to D-ASA owners. Other implementations may relay on other
    // # roles, external Apps through C2C calls (e.g., an order book), or off-chain transfer agents.
    // assert Txn.sender == sender_holding_address, err.UNAUTHORIZED
    txn Sender
    dig 3
    dup
    cover 2
    ==
    assert // Not authorized
    // smart_contracts/base_d_asa/contract.py:333
    // self.assert_is_not_defaulted()
    callsub assert_is_not_defaulted
    // smart_contracts/base_d_asa/contract.py:334
    // self.assert_is_not_suspended()
    callsub assert_is_not_suspended
    // smart_contracts/base_d_asa/contract.py:160
    // assert holding_address in self.account, err.INVALID_HOLDING_ADDRESS
    bytec_1 // 0x52333023
    swap
    concat
    dup
    bury 9
    dup
    box_len
    bury 1
    assert // Invalid account holding address
    bytec_1 // 0x52333023
    dig 3
    concat
    dup
    bury 9
    dup
    box_len
    bury 1
    assert // Invalid account holding address
    // smart_contracts/base_d_asa/contract.py:337
    // assert not self.account[sender_holding_address].suspended, err.SUSPENDED
    swap
    box_get
    pop
    dup
    intc 4 // 448
    getbit
    !
    assert // Suspended operations
    // smart_contracts/base_d_asa/contract.py:338
    // assert not self.account[receiver_holding_address].suspended, err.SUSPENDED
    swap
    box_get
    pop
    dup
    intc 4 // 448
    getbit
    !
    assert // Suspended operations
    // smart_contracts/base_d_asa/contract.py:339
    // assert units <= self.account[sender_holding_address].units, err.OVER_TRANSFER
    dig 1
    intc_2 // 32
    extract_uint64
    dig 3
    >=
    assert // Insufficient sender units to transfer
    // smart_contracts/base_d_asa/contract.py:346
    // sender_unit_value = self.account[sender_holding_address].unit_value
    swap
    extract 40 8
    bury 10
    // smart_contracts/base_d_asa/contract.py:347
    // if self.account[receiver_holding_address].units > 0:
    intc_2 // 32
    extract_uint64
    bz asset_transfer_else_body@12
    // smart_contracts/base_d_asa/contract.py:275
    // self.account[sender].unit_value == self.account[receiver].unit_value
    dig 7
    box_get
    assert // check self.account entry exists
    pushint 40
    extract_uint64
    dig 7
    box_get
    assert // check self.account entry exists
    pushint 40
    extract_uint64
    ==
    // smart_contracts/base_d_asa/contract.py:275-276
    // self.account[sender].unit_value == self.account[receiver].unit_value
    // and self.account[sender].paid_coupons == self.account[receiver].paid_coupons
    bz asset_transfer_bool_false@10
    // smart_contracts/base_d_asa/contract.py:276
    // and self.account[sender].paid_coupons == self.account[receiver].paid_coupons
    dig 7
    box_get
    assert // check self.account entry exists
    pushint 48
    extract_uint64
    dig 7
    box_get
    assert // check self.account entry exists
    pushint 48
    extract_uint64
    ==
    // smart_contracts/base_d_asa/contract.py:275-276
    // self.account[sender].unit_value == self.account[receiver].unit_value
    // and self.account[sender].paid_coupons == self.account[receiver].paid_coupons
    bz asset_transfer_bool_false@10
    intc_1 // 1

asset_transfer_bool_merge@11:
    // smart_contracts/base_d_asa/contract.py:274-277
    // assert (
    //     self.account[sender].unit_value == self.account[receiver].unit_value
    //     and self.account[sender].paid_coupons == self.account[receiver].paid_coupons
    // ), err.NON_FUNGIBLE_UNITS
    assert // Sender and receiver units are not fungible

asset_transfer_after_if_else@13:
    // smart_contracts/fixed_coupon_bond/contract.py:178-179
    // # Transfer is forbidden in case of pending coupon payments
    // due_coupons = self.count_due_coupons()
    callsub count_due_coupons
    // smart_contracts/fixed_coupon_bond/contract.py:180
    // self.assert_no_pending_coupon_payment(sender_holding_address, due_coupons)
    dig 3
    dup
    cover 2
    dig 1
    callsub assert_no_pending_coupon_payment
    // smart_contracts/fixed_coupon_bond/contract.py:182-183
    // # Transferred units value (must be computed before the transfer)
    // sender_unit_value = self.account[sender_holding_address].unit_value
    dig 9
    dup
    cover 3
    box_get
    assert // check self.account entry exists
    pushint 40
    extract_uint64
    bury 7
    // smart_contracts/fixed_coupon_bond/contract.py:184-186
    // accrued_interest = self.accrued_interest_amount(
    //     sender_holding_address, units, due_coupons
    // )
    swap
    dig 3
    dup
    cover 4
    uncover 2
    callsub accrued_interest_amount
    bury 8
    // smart_contracts/base_d_asa/contract.py:380
    // self.account[sender_holding_address].units -= units
    dup
    box_get
    assert // check self.account entry exists
    intc_2 // 32
    extract_uint64
    dig 2
    -
    itob
    dig 1
    intc_2 // 32
    uncover 2
    box_replace
    // smart_contracts/base_d_asa/contract.py:381
    // self.account[receiver_holding_address].units += units
    dig 8
    dup
    box_get
    assert // check self.account entry exists
    intc_2 // 32
    extract_uint64
    uncover 3
    +
    itob
    intc_2 // 32
    swap
    box_replace
    // smart_contracts/base_d_asa/contract.py:316
    // if self.account[holding_address].units == 0:
    box_get
    pop
    intc_2 // 32
    extract_uint64
    bnz asset_transfer_after_if_else@17
    // smart_contracts/base_d_asa/contract.py:317
    // self.account[holding_address].unit_value = UInt64(0)
    intc_0 // 0
    itob
    dig 8
    dup
    cover 2
    pushint 40
    dig 2
    box_replace
    // smart_contracts/base_d_asa/contract.py:318
    // self.account[holding_address].paid_coupons = UInt64(0)
    pushint 48
    swap
    box_replace

asset_transfer_after_if_else@17:
    // smart_contracts/fixed_coupon_bond/contract.py:189
    // return units * sender_unit_value + accrued_interest
    dup
    dig 4
    *
    dig 6
    +
    // smart_contracts/fixed_coupon_bond/contract.py:143
    // @arc4.abimethod
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

asset_transfer_bool_false@10:
    intc_0 // 0
    b asset_transfer_bool_merge@11

asset_transfer_else_body@12:
    // smart_contracts/base_d_asa/contract.py:352
    // self.account[receiver_holding_address].unit_value = sender_unit_value
    dig 6
    dup
    pushint 40
    dig 11
    box_replace
    // smart_contracts/base_d_asa/contract.py:353-355
    // self.account[receiver_holding_address].paid_coupons = self.account[
    //     sender_holding_address
    // ].paid_coupons
    dig 8
    box_get
    assert // check self.account entry exists
    extract 48 8
    pushint 48
    swap
    box_replace
    b asset_transfer_after_if_else@13

asset_transfer_bool_false@5:
    intc_0 // 0
    b asset_transfer_bool_merge@6


// smart_contracts.fixed_coupon_bond.contract.FixedCouponBond.pay_coupon[routing]() -> void:
pay_coupon:
    // smart_contracts/fixed_coupon_bond/contract.py:191
    // @arc4.abimethod
    txna ApplicationArgs 1
    dupn 2
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    swap
    // smart_contracts/base_d_asa/contract.py:100
    // return self.status == cfg.STATUS_ACTIVE
    intc_0 // 0
    bytec_2 // "status"
    app_global_get_ex
    assert // check self.status exists
    pushint 100
    ==
    // smart_contracts/fixed_coupon_bond/contract.py:214-215
    // # The reference implementation does not restrict caller authorization
    // assert self.status_is_active(), err.UNAUTHORIZED
    assert // Not authorized
    // smart_contracts/fixed_coupon_bond/contract.py:216
    // self.assert_is_not_defaulted()
    callsub assert_is_not_defaulted
    // smart_contracts/fixed_coupon_bond/contract.py:217
    // self.assert_is_not_suspended()
    callsub assert_is_not_suspended
    // smart_contracts/base_d_asa/contract.py:160
    // assert holding_address in self.account, err.INVALID_HOLDING_ADDRESS
    bytec_1 // 0x52333023
    dig 1
    concat
    dup
    cover 2
    dup
    box_len
    bury 1
    assert // Invalid account holding address
    // smart_contracts/fixed_coupon_bond/contract.py:219
    // units = self.account[holding_address].units
    dup
    box_get
    pop
    intc_2 // 32
    extract_uint64
    dup
    cover 3
    // smart_contracts/fixed_coupon_bond/contract.py:220
    // assert units > 0, err.NO_UNITS
    assert // No D-ASA units
    // smart_contracts/fixed_coupon_bond/contract.py:221
    // due_coupons = self.count_due_coupons()
    callsub count_due_coupons
    // smart_contracts/fixed_coupon_bond/contract.py:222
    // account_paid_coupons = self.account[holding_address].paid_coupons
    swap
    box_get
    assert // check self.account entry exists
    pushint 48
    extract_uint64
    dup
    cover 3
    // smart_contracts/fixed_coupon_bond/contract.py:223
    // assert due_coupons > account_paid_coupons, err.NO_DUE_COUPON
    swap
    dig 1
    >
    assert // No due coupon to pay
    // smart_contracts/fixed_coupon_bond/contract.py:224-227
    // # The following conditions verify if other accounts are still waiting for the payment of previous coupons
    // assert self.all_due_coupons_paid(
    //     account_paid_coupons
    // ), err.PENDING_COUPON_PAYMENT
    callsub all_due_coupons_paid
    assert // Pending due coupon payment
    // smart_contracts/fixed_coupon_bond/contract.py:230
    // if self.is_payment_executable(holding_address):
    callsub is_payment_executable
    bz pay_coupon_else_body@3
    // smart_contracts/fixed_coupon_bond/contract.py:232
    // self.account_total_units_value(holding_address),
    dig 4
    callsub account_total_units_value
    // smart_contracts/fixed_coupon_bond/contract.py:233
    // account_paid_coupons + 1,
    dig 1
    intc_1 // 1
    +
    // smart_contracts/fixed_coupon_bond/contract.py:231-234
    // payment_amount = self.coupon_interest_amount(
    //     self.account_total_units_value(holding_address),
    //     account_paid_coupons + 1,
    // )
    callsub coupon_interest_amount
    dupn 2
    // smart_contracts/fixed_coupon_bond/contract.py:235-236
    // # The reference implementation has on-chain payment agent
    // self.assert_enough_funds(payment_amount)
    callsub assert_enough_funds
    // smart_contracts/fixed_coupon_bond/contract.py:237-238
    // # The reference implementation has the same asset for denomination and settlement, no conversion needed
    // self.pay(self.account[holding_address].payment_address, payment_amount)
    dig 4
    box_get
    assert // check self.account entry exists
    extract 0 32
    swap
    callsub pay

pay_coupon_after_if_else@4:
    // smart_contracts/fixed_coupon_bond/contract.py:243
    // self.account[holding_address].paid_coupons += 1
    dig 3
    dup
    box_get
    assert // check self.account entry exists
    pushint 48
    extract_uint64
    intc_1 // 1
    +
    itob
    pushint 48
    swap
    box_replace
    // smart_contracts/fixed_coupon_bond/contract.py:244
    // self.paid_coupon_units += units
    intc_0 // 0
    bytec 24 // "paid_coupon_units"
    app_global_get_ex
    assert // check self.paid_coupon_units exists
    dig 3
    +
    bytec 24 // "paid_coupon_units"
    swap
    app_global_put
    // smart_contracts/fixed_coupon_bond/contract.py:247
    // timestamp=Global.latest_timestamp,
    global LatestTimestamp
    // smart_contracts/fixed_coupon_bond/contract.py:245-249
    // return typ.PaymentResult(
    //     amount=payment_amount,
    //     timestamp=Global.latest_timestamp,
    //     context=payment_info,  # TODO: Add info on failed payment
    // )
    swap
    itob
    swap
    itob
    concat
    dig 4
    dup
    len
    itob
    extract 6 2
    swap
    concat
    swap
    bytec 33 // 0x0012
    concat
    swap
    concat
    // smart_contracts/fixed_coupon_bond/contract.py:191
    // @arc4.abimethod
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

pay_coupon_else_body@3:
    // smart_contracts/fixed_coupon_bond/contract.py:240-241
    // # Accounts suspended or not opted in at the time of payments must not stall the D-ASA
    // payment_amount = UInt64()
    intc_0 // 0
    b pay_coupon_after_if_else@4


// smart_contracts.fixed_coupon_bond.contract.FixedCouponBond.pay_principal[routing]() -> void:
pay_principal:
    // smart_contracts/fixed_coupon_bond/contract.py:251
    // @arc4.abimethod
    txna ApplicationArgs 1
    dupn 2
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    swap
    // smart_contracts/base_d_asa/contract.py:100
    // return self.status == cfg.STATUS_ACTIVE
    intc_0 // 0
    bytec_2 // "status"
    app_global_get_ex
    assert // check self.status exists
    pushint 100
    ==
    // smart_contracts/base_d_asa/contract.py:385-386
    // # The reference implementation does not restrict caller authorization
    // assert self.status_is_active(), err.UNAUTHORIZED
    assert // Not authorized
    // smart_contracts/base_d_asa/contract.py:387
    // self.assert_is_not_defaulted()
    callsub assert_is_not_defaulted
    // smart_contracts/base_d_asa/contract.py:388
    // self.assert_is_not_suspended()
    callsub assert_is_not_suspended
    // smart_contracts/base_d_asa/contract.py:160
    // assert holding_address in self.account, err.INVALID_HOLDING_ADDRESS
    bytec_1 // 0x52333023
    dig 1
    concat
    dup
    cover 2
    dup
    box_len
    bury 1
    assert // Invalid account holding address
    // smart_contracts/base_d_asa/contract.py:390
    // units = self.account[holding_address].units
    box_get
    pop
    intc_2 // 32
    extract_uint64
    // smart_contracts/base_d_asa/contract.py:391
    // assert units > 0, err.NO_UNITS
    assert // No D-ASA units
    // smart_contracts/base_d_asa/contract.py:392
    // assert Global.latest_timestamp >= self.maturity_date, err.NOT_MATURE
    global LatestTimestamp
    intc_0 // 0
    bytec 7 // "maturity_date"
    app_global_get_ex
    assert // check self.maturity_date exists
    >=
    assert // Not mature
    // smart_contracts/fixed_coupon_bond/contract.py:278
    // self.count_due_coupons()
    callsub count_due_coupons
    // smart_contracts/fixed_coupon_bond/contract.py:276-279
    // # Principal payment is forbidden in case of pending coupon payments
    // assert self.all_due_coupons_paid(
    //     self.count_due_coupons()
    // ), err.PENDING_COUPON_PAYMENT
    callsub all_due_coupons_paid
    assert // Pending due coupon payment
    // smart_contracts/fixed_coupon_bond/contract.py:282
    // if self.is_payment_executable(holding_address):
    callsub is_payment_executable
    bz pay_principal_else_body@3
    // smart_contracts/fixed_coupon_bond/contract.py:283
    // payment_amount = self.account_total_units_value(holding_address)
    dig 2
    callsub account_total_units_value
    dupn 2
    // smart_contracts/fixed_coupon_bond/contract.py:284-285
    // # The reference implementation has on-chain payment agent
    // self.assert_enough_funds(payment_amount)
    callsub assert_enough_funds
    // smart_contracts/fixed_coupon_bond/contract.py:286-287
    // # The reference implementation has the same asset for denomination and settlement, no conversion needed
    // self.pay(self.account[holding_address].payment_address, payment_amount)
    dig 2
    box_get
    assert // check self.account entry exists
    extract 0 32
    swap
    callsub pay

pay_principal_after_if_else@4:
    // smart_contracts/base_d_asa/contract.py:396
    // self.circulating_units -= self.account[holding_address].units
    intc_0 // 0
    bytec 4 // "circulating_units"
    app_global_get_ex
    assert // check self.circulating_units exists
    dig 2
    dup
    cover 2
    box_get
    assert // check self.account entry exists
    intc_2 // 32
    extract_uint64
    -
    bytec 4 // "circulating_units"
    swap
    app_global_put
    // smart_contracts/base_d_asa/contract.py:397
    // self.account[holding_address].units = UInt64()
    intc_0 // 0
    itob
    intc_2 // 32
    swap
    box_replace
    // smart_contracts/base_d_asa/contract.py:398
    // self.end_if_no_circulating_units()
    callsub end_if_no_circulating_units
    // smart_contracts/fixed_coupon_bond/contract.py:295
    // timestamp=Global.latest_timestamp,
    global LatestTimestamp
    // smart_contracts/fixed_coupon_bond/contract.py:293-297
    // return typ.PaymentResult(
    //     amount=payment_amount,
    //     timestamp=Global.latest_timestamp,
    //     context=payment_info,  # TODO: Add info on failed payment
    // )
    swap
    itob
    swap
    itob
    concat
    dig 2
    dup
    len
    itob
    extract 6 2
    swap
    concat
    swap
    bytec 33 // 0x0012
    concat
    swap
    concat
    // smart_contracts/fixed_coupon_bond/contract.py:251
    // @arc4.abimethod
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

pay_principal_else_body@3:
    // smart_contracts/fixed_coupon_bond/contract.py:289-290
    // # Accounts suspended or not opted in at the time of payments must not stall the D-ASA
    // payment_amount = UInt64()
    intc_0 // 0
    b pay_principal_after_if_else@4


// smart_contracts.fixed_coupon_bond.contract.FixedCouponBond.get_account_units_current_value[routing]() -> void:
get_account_units_current_value:
    intc_0 // 0
    bytec_3 // ""
    dupn 4
    // smart_contracts/fixed_coupon_bond/contract.py:299
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/fixed_coupon_bond/contract.py:320
    // self.primary_distribution_opening_date
    intc_0 // 0
    bytec 9 // "primary_distribution_opening_date"
    app_global_get_ex
    assert // check self.primary_distribution_opening_date exists
    // smart_contracts/fixed_coupon_bond/contract.py:320-321
    // self.primary_distribution_opening_date
    // and Global.latest_timestamp >= self.primary_distribution_opening_date
    bz get_account_units_current_value_bool_false@4
    // smart_contracts/fixed_coupon_bond/contract.py:321
    // and Global.latest_timestamp >= self.primary_distribution_opening_date
    global LatestTimestamp
    intc_0 // 0
    bytec 9 // "primary_distribution_opening_date"
    app_global_get_ex
    assert // check self.primary_distribution_opening_date exists
    >=
    // smart_contracts/fixed_coupon_bond/contract.py:320-321
    // self.primary_distribution_opening_date
    // and Global.latest_timestamp >= self.primary_distribution_opening_date
    bz get_account_units_current_value_bool_false@4
    intc_1 // 1

get_account_units_current_value_bool_merge@5:
    // smart_contracts/fixed_coupon_bond/contract.py:319-322
    // assert (
    //     self.primary_distribution_opening_date
    //     and Global.latest_timestamp >= self.primary_distribution_opening_date
    // ), err.NO_PRIMARY_DISTRIBUTION
    assert // Primary distribution not yet executed
    // smart_contracts/base_d_asa/contract.py:160
    // assert holding_address in self.account, err.INVALID_HOLDING_ADDRESS
    bytec_1 // 0x52333023
    dig 2
    concat
    dup
    bury 9
    box_len
    bury 1
    assert // Invalid account holding address
    // smart_contracts/fixed_coupon_bond/contract.py:324
    // assert 0 < units <= self.account[holding_address].units, err.INVALID_UNITS
    dup
    bz get_account_units_current_value_bool_false@8
    dig 7
    box_get
    assert // check self.account entry exists
    intc_2 // 32
    extract_uint64
    dig 1
    >=
    bz get_account_units_current_value_bool_false@8
    intc_1 // 1

get_account_units_current_value_bool_merge@9:
    // smart_contracts/fixed_coupon_bond/contract.py:324
    // assert 0 < units <= self.account[holding_address].units, err.INVALID_UNITS
    assert // Invalid amount of units for the account
    // smart_contracts/fixed_coupon_bond/contract.py:326-327
    // # Value during primary distribution and at maturity
    // account_units_nominal_value = self.account_units_value(holding_address, units)
    dig 1
    dup
    dig 2
    callsub account_units_value
    bury 8
    // smart_contracts/fixed_coupon_bond/contract.py:328-329
    // # Accruing interest during primary distribution and at maturity
    // accrued_interest = UInt64()
    intc_0 // 0
    bury 7
    // smart_contracts/fixed_coupon_bond/contract.py:330
    // numerator = UInt64()
    intc_0 // 0
    bury 4
    // smart_contracts/fixed_coupon_bond/contract.py:331
    // denominator = UInt64()
    intc_0 // 0
    bury 6
    // smart_contracts/fixed_coupon_bond/contract.py:333-334
    // # Accruing interest
    // due_coupons = self.count_due_coupons()
    callsub count_due_coupons
    dup
    bury 6
    // smart_contracts/fixed_coupon_bond/contract.py:335
    // self.assert_no_pending_coupon_payment(holding_address, due_coupons)
    swap
    dig 1
    callsub assert_no_pending_coupon_payment
    // smart_contracts/fixed_coupon_bond/contract.py:336
    // if self.is_accruing_interest(due_coupons):
    callsub is_accruing_interest
    bz get_account_units_current_value_after_if_else@11
    // smart_contracts/fixed_coupon_bond/contract.py:337
    // day_count_factor = self.day_count_factor(due_coupons)
    dig 3
    dup
    callsub day_count_factor
    // smart_contracts/fixed_coupon_bond/contract.py:338-340
    // accrued_interest = self.accrued_interest_amount(
    //     holding_address, units, due_coupons
    // )
    dig 3
    dig 3
    uncover 3
    callsub accrued_interest_amount
    bury 7
    // smart_contracts/fixed_coupon_bond/contract.py:341
    // numerator = day_count_factor.numerator
    dup
    intc_0 // 0
    extract_uint64
    bury 4
    // smart_contracts/fixed_coupon_bond/contract.py:342
    // denominator = day_count_factor.denominator
    intc_3 // 8
    extract_uint64
    bury 5

get_account_units_current_value_after_if_else@11:
    // smart_contracts/fixed_coupon_bond/contract.py:346-349
    // day_count_factor=typ.DayCountFactor(
    //     numerator=numerator,
    //     denominator=denominator,
    // ),
    dig 2
    itob
    dig 5
    itob
    concat
    // smart_contracts/fixed_coupon_bond/contract.py:343-350
    // return typ.CurrentUnitsValue(
    //     units_value=account_units_nominal_value,
    //     accrued_interest=accrued_interest,
    //     day_count_factor=typ.DayCountFactor(
    //         numerator=numerator,
    //         denominator=denominator,
    //     ),
    // )
    dig 7
    itob
    dig 7
    itob
    concat
    swap
    concat
    // smart_contracts/fixed_coupon_bond/contract.py:299
    // @arc4.abimethod(readonly=True)
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

get_account_units_current_value_bool_false@8:
    intc_0 // 0
    b get_account_units_current_value_bool_merge@9

get_account_units_current_value_bool_false@4:
    intc_0 // 0
    b get_account_units_current_value_bool_merge@5


// smart_contracts.fixed_coupon_bond.contract.FixedCouponBond.get_coupon_rates[routing]() -> void:
get_coupon_rates:
    // smart_contracts/fixed_coupon_bond/contract.py:360
    // coupon_rates = typ.CouponRates()
    bytec 34 // 0x0000
    // smart_contracts/base_d_asa/contract.py:100
    // return self.status == cfg.STATUS_ACTIVE
    intc_0 // 0
    bytec_2 // "status"
    app_global_get_ex
    assert // check self.status exists
    pushint 100
    ==
    // smart_contracts/fixed_coupon_bond/contract.py:361
    // if self.status_is_active():
    bz get_coupon_rates_after_if_else@3
    // smart_contracts/fixed_coupon_bond/contract.py:362
    // coupon_rates = self.coupon_rates.value.copy()
    bytec 15 // 0x636f75706f6e5261746573
    box_get
    swap
    bury 2
    assert // check self.coupon_rates exists

get_coupon_rates_after_if_else@3:
    // smart_contracts/fixed_coupon_bond/contract.py:352
    // @arc4.abimethod(readonly=True)
    bytec_0 // 0x151f7c75
    dig 1
    concat
    log
    intc_1 // 1
    return


// smart_contracts.fixed_coupon_bond.contract.FixedCouponBond.get_payment_amount[routing]() -> void:
get_payment_amount:
    bytec_3 // ""
    // smart_contracts/fixed_coupon_bond/contract.py:365
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dupn 2
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/base_d_asa/contract.py:160
    // assert holding_address in self.account, err.INVALID_HOLDING_ADDRESS
    bytec_1 // 0x52333023
    swap
    concat
    dup
    box_len
    bury 1
    assert // Invalid account holding address
    // smart_contracts/fixed_coupon_bond/contract.py:380
    // interest_amount = UInt64()
    intc_0 // 0
    // smart_contracts/fixed_coupon_bond/contract.py:381
    // principal_amount = UInt64()
    dupn 2
    // smart_contracts/base_d_asa/contract.py:100
    // return self.status == cfg.STATUS_ACTIVE
    bytec_2 // "status"
    app_global_get_ex
    assert // check self.status exists
    pushint 100
    ==
    // smart_contracts/fixed_coupon_bond/contract.py:382
    // if self.status_is_active():
    bz get_payment_amount_after_if_else@6
    // smart_contracts/fixed_coupon_bond/contract.py:383
    // paid_coupons = self.account[holding_address].paid_coupons
    dig 2
    box_get
    assert // check self.account entry exists
    pushint 48
    extract_uint64
    dup
    bury 6
    // smart_contracts/fixed_coupon_bond/contract.py:384
    // if paid_coupons < self.total_coupons:
    intc_0 // 0
    bytec 5 // "total_coupons"
    app_global_get_ex
    assert // check self.total_coupons exists
    <
    bz get_payment_amount_else_body@4
    // smart_contracts/fixed_coupon_bond/contract.py:387
    // self.account_total_units_value(holding_address),
    dig 3
    callsub account_total_units_value
    // smart_contracts/fixed_coupon_bond/contract.py:388
    // paid_coupons + 1,
    dig 5
    intc_1 // 1
    +
    // smart_contracts/fixed_coupon_bond/contract.py:385-389
    // # Coupon Payment
    // interest_amount = self.coupon_interest_amount(
    //     self.account_total_units_value(holding_address),
    //     paid_coupons + 1,
    // )
    callsub coupon_interest_amount
    bury 2

get_payment_amount_after_if_else@6:
    // smart_contracts/fixed_coupon_bond/contract.py:393-396
    // return typ.PaymentAmounts(
    //     interest=interest_amount,
    //     principal=principal_amount,
    // )
    dig 1
    itob
    dig 1
    itob
    concat
    // smart_contracts/fixed_coupon_bond/contract.py:365
    // @arc4.abimethod(readonly=True)
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

get_payment_amount_else_body@4:
    // smart_contracts/fixed_coupon_bond/contract.py:391-392
    // # Principal Payment
    // principal_amount = self.account_total_units_value(holding_address)
    dig 3
    callsub account_total_units_value
    bury 1
    b get_payment_amount_after_if_else@6


// smart_contracts.fixed_coupon_bond.contract.FixedCouponBond.get_coupons_status[routing]() -> void:
get_coupons_status:
    // smart_contracts/fixed_coupon_bond/contract.py:407
    // due_coupons = self.count_due_coupons()
    callsub count_due_coupons
    dupn 2
    // smart_contracts/fixed_coupon_bond/contract.py:408
    // next_coupon_due_date = self.next_coupon_due_date(due_coupons)
    callsub next_coupon_due_date
    swap
    // smart_contracts/fixed_coupon_bond/contract.py:409
    // all_due_coupons_paid = self.all_due_coupons_paid(due_coupons)
    dup
    callsub all_due_coupons_paid
    swap
    // smart_contracts/fixed_coupon_bond/contract.py:410
    // numerator = UInt64()
    intc_0 // 0
    swap
    // smart_contracts/fixed_coupon_bond/contract.py:411
    // denominator = UInt64()
    intc_0 // 0
    swap
    // smart_contracts/fixed_coupon_bond/contract.py:412
    // if self.is_accruing_interest(due_coupons):
    callsub is_accruing_interest
    bz get_coupons_status_after_if_else@3
    // smart_contracts/fixed_coupon_bond/contract.py:413
    // day_count_factor = self.day_count_factor(due_coupons)
    dig 4
    callsub day_count_factor
    // smart_contracts/fixed_coupon_bond/contract.py:414
    // numerator = day_count_factor.numerator
    dup
    intc_0 // 0
    extract_uint64
    bury 3
    // smart_contracts/fixed_coupon_bond/contract.py:415
    // denominator = day_count_factor.denominator
    intc_3 // 8
    extract_uint64
    bury 1

get_coupons_status_after_if_else@3:
    // smart_contracts/fixed_coupon_bond/contract.py:417
    // total_coupons=self.total_coupons,
    intc_0 // 0
    bytec 5 // "total_coupons"
    app_global_get_ex
    assert // check self.total_coupons exists
    // smart_contracts/fixed_coupon_bond/contract.py:420-423
    // day_count_factor=typ.DayCountFactor(
    //     numerator=numerator,
    //     denominator=denominator,
    // ),
    dig 2
    itob
    dig 2
    itob
    concat
    // smart_contracts/fixed_coupon_bond/contract.py:416-425
    // return typ.CouponsInfo(
    //     total_coupons=self.total_coupons,
    //     due_coupons=due_coupons,
    //     next_coupon_due_date=next_coupon_due_date,
    //     day_count_factor=typ.DayCountFactor(
    //         numerator=numerator,
    //         denominator=denominator,
    //     ),
    //     all_due_coupons_paid=all_due_coupons_paid,
    // )
    swap
    itob
    dig 6
    itob
    concat
    dig 5
    itob
    concat
    swap
    concat
    bytec 27 // 0x00
    intc_0 // 0
    dig 5
    setbit
    concat
    // smart_contracts/fixed_coupon_bond/contract.py:398
    // @arc4.abimethod(readonly=True)
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.base_d_asa.contract.BaseDAsa.asset_create[routing]() -> void:
asset_create:
    // smart_contracts/base_d_asa/contract.py:400
    // @arc4.abimethod(create="require")
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    len
    dig 1
    pushint 38
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 40
    ==
    assert // invalid tail pointer at index 7 of (uint8,uint8,uint8,uint8,uint8,uint8,uint8[32],(len+utf8[]))
    dig 2
    swap
    dig 2
    substring3
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 42
    +
    ==
    assert // invalid number of bytes for smart_contracts.abi_types.AssetMetadata
    // smart_contracts/base_d_asa/contract.py:409
    // self.arranger.value = arranger
    bytec 16 // 0x52323023
    uncover 2
    app_global_put
    // smart_contracts/base_d_asa/contract.py:410
    // self.metadata = metadata.bytes
    bytec 18 // "metadata"
    swap
    app_global_put
    // smart_contracts/base_d_asa/contract.py:400
    // @arc4.abimethod(create="require")
    intc_1 // 1
    return


// smart_contracts.base_d_asa.contract.BaseDAsa.asset_update[routing]() -> void:
asset_update:
    // smart_contracts/base_d_asa/contract.py:412
    // @arc4.abimethod(allow_actions=["UpdateApplication"])
    txna ApplicationArgs 1
    dup
    len
    dig 1
    pushint 38
    extract_uint16 // on error: invalid tuple encoding
    dup
    pushint 40
    ==
    assert // invalid tail pointer at index 7 of (uint8,uint8,uint8,uint8,uint8,uint8,uint8[32],(len+utf8[]))
    dig 2
    swap
    dig 2
    substring3
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 42
    +
    ==
    assert // invalid number of bytes for smart_contracts.abi_types.AssetMetadata
    // smart_contracts/base_d_asa/contract.py:417-420
    // # The reference implementation grants the update permissions to the Arranger.
    // # Other implementations may disable D-ASA application updatability or change its authorizations.
    // # ⚠️ WARNING: Application updates must be executed VERY carefully, as they might introduce breaking changes.
    // self.assert_caller_is_arranger()
    callsub assert_caller_is_arranger
    // smart_contracts/base_d_asa/contract.py:421
    // self.metadata = metadata.bytes
    bytec 18 // "metadata"
    swap
    app_global_put
    // smart_contracts/base_d_asa/contract.py:412
    // @arc4.abimethod(allow_actions=["UpdateApplication"])
    intc_1 // 1
    return


// smart_contracts.base_d_asa.contract.BaseDAsa.asset_config[routing]() -> void:
asset_config:
    intc_0 // 0
    bytec_3 // ""
    dupn 2
    // smart_contracts/base_d_asa/contract.py:423
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    swap
    txna ApplicationArgs 3
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    swap
    txna ApplicationArgs 4
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    swap
    txna ApplicationArgs 5
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    swap
    txna ApplicationArgs 6
    dup
    cover 2
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    txna ApplicationArgs 7
    dup
    cover 2
    len
    pushint 2
    ==
    assert // invalid number of bytes for arc4.uint16
    txna ApplicationArgs 8
    dup
    cover 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 3
    pushint 2
    *
    pushint 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint16>
    txna ApplicationArgs 9
    dup
    cover 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 3
    intc_3 // 8
    *
    pushint 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<uint64>
    txna ApplicationArgs 10
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    cover 3
    pushint 16
    *
    pushint 2
    +
    swap
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<tuple<uint64,uint64>>
    // smart_contracts/base_d_asa/contract.py:467
    // self.assert_caller_is_arranger()
    callsub assert_caller_is_arranger
    // smart_contracts/base_d_asa/contract.py:468
    // assert self.status == cfg.STATUS_EMPTY, err.ALREADY_CONFIGURED
    intc_0 // 0
    bytec_2 // "status"
    app_global_get_ex
    assert // check self.status exists
    !
    assert // D-ASA already configured
    // smart_contracts/base_d_asa/contract.py:165
    // denomination_asset_id != UInt64(0) and Asset(denomination_asset_id).creator
    bz asset_config_bool_false@4
    dig 11
    asset_params_get AssetCreator
    assert // asset exists
    global ZeroAddress
    !=
    bz asset_config_bool_false@4
    intc_1 // 1

asset_config_bool_merge@5:
    // smart_contracts/base_d_asa/contract.py:163-166
    // # The reference implementation has on-chain denomination with ASA
    // assert (
    //     denomination_asset_id != UInt64(0) and Asset(denomination_asset_id).creator
    // ), err.INVALID_DENOMINATION
    assert // Denomination asset is not properly set
    // smart_contracts/base_d_asa/contract.py:169
    // self.denomination_asset_id = denomination_asset_id
    bytec 25 // "denomination_asset_id"
    dig 12
    dup
    cover 2
    app_global_put
    // smart_contracts/base_d_asa/contract.py:174
    // settlement_asset_id == self.denomination_asset_id
    dig 11
    dup
    uncover 2
    ==
    // smart_contracts/base_d_asa/contract.py:172-175
    // # The reference implementation settlement asset is the denomination asset
    // assert (
    //     settlement_asset_id == self.denomination_asset_id
    // ), err.INVALID_SETTLEMENT_ASSET
    assert // Different settlement asset not supported, must be equal to denomination asset
    // smart_contracts/base_d_asa/contract.py:178
    // self.settlement_asset_id = settlement_asset_id
    bytec 8 // "settlement_asset_id"
    dig 1
    app_global_put
    // smart_contracts/base_d_asa/contract.py:179-185
    // # The reference implementation has on-chain settlement with ASA
    // itxn.AssetTransfer(
    //     xfer_asset=self.settlement_asset_id,
    //     asset_receiver=Global.current_application_address,
    //     asset_amount=0,
    //     fee=Global.min_txn_fee,
    // ).submit()
    itxn_begin
    // smart_contracts/base_d_asa/contract.py:184
    // fee=Global.min_txn_fee,
    global MinTxnFee
    // smart_contracts/base_d_asa/contract.py:182
    // asset_receiver=Global.current_application_address,
    global CurrentApplicationAddress
    // smart_contracts/base_d_asa/contract.py:183
    // asset_amount=0,
    intc_0 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    swap
    itxn_field XferAsset
    // smart_contracts/base_d_asa/contract.py:179-180
    // # The reference implementation has on-chain settlement with ASA
    // itxn.AssetTransfer(
    pushint 4 // axfer
    itxn_field TypeEnum
    itxn_field Fee
    // smart_contracts/base_d_asa/contract.py:179-185
    // # The reference implementation has on-chain settlement with ASA
    // itxn.AssetTransfer(
    //     xfer_asset=self.settlement_asset_id,
    //     asset_receiver=Global.current_application_address,
    //     asset_amount=0,
    //     fee=Global.min_txn_fee,
    // ).submit()
    itxn_submit
    // smart_contracts/base_d_asa/contract.py:478-479
    // # Set Principal and Minimum Denomination
    // assert principal % minimum_denomination == 0, err.INVALID_MINIMUM_DENOMINATION
    dig 9
    dup
    dig 9
    dup
    cover 2
    %
    !
    assert // Minimum denomination is not a divisor of principal
    // smart_contracts/base_d_asa/contract.py:480
    // self.unit_value = minimum_denomination
    bytec 17 // "unit_value"
    dig 1
    app_global_put
    // smart_contracts/base_d_asa/contract.py:481
    // self.total_units = principal // minimum_denomination
    /
    bytec 12 // "total_units"
    swap
    app_global_put
    // smart_contracts/base_d_asa/contract.py:482
    // self.principal_discount = principal_discount
    bytec 19 // "principal_discount"
    dig 9
    app_global_put
    // smart_contracts/base_d_asa/contract.py:484-485
    // # Set Day-Count Convention
    // self.assert_day_count_convention(day_count_convention.as_uint64())
    dig 6
    btoi
    dup
    bury 15
    // smart_contracts/base_d_asa/contract.py:188-192
    // # The reference implementation supports only the Actual/Actual and Continuous day-count conventions
    // assert day_count_convention in (
    //     UInt64(cst.DCC_A_A),
    //     UInt64(cst.DCC_CONT),
    // ), err.INVALID_DAY_COUNT_CONVENTION
    bz asset_config_bool_true@15
    dig 13
    // smart_contracts/base_d_asa/contract.py:191
    // UInt64(cst.DCC_CONT),
    intc 5 // 255
    // smart_contracts/base_d_asa/contract.py:188-192
    // # The reference implementation supports only the Actual/Actual and Continuous day-count conventions
    // assert day_count_convention in (
    //     UInt64(cst.DCC_A_A),
    //     UInt64(cst.DCC_CONT),
    // ), err.INVALID_DAY_COUNT_CONVENTION
    ==
    bz asset_config_bool_false@16

asset_config_bool_true@15:
    intc_1 // 1

asset_config_bool_merge@17:
    // smart_contracts/base_d_asa/contract.py:188-192
    // # The reference implementation supports only the Actual/Actual and Continuous day-count conventions
    // assert day_count_convention in (
    //     UInt64(cst.DCC_A_A),
    //     UInt64(cst.DCC_CONT),
    // ), err.INVALID_DAY_COUNT_CONVENTION
    assert // Invalid day-count convention ID
    // smart_contracts/base_d_asa/contract.py:195
    // self.day_count_convention = day_count_convention
    bytec 11 // "day_count_convention"
    dig 14
    app_global_put
    // smart_contracts/base_d_asa/contract.py:488-489
    // # Set Interest Rate
    // self.assert_interest_rate(interest_rate.as_uint64())
    dig 5
    btoi
    bury 13
    // smart_contracts/base_d_asa/contract.py:198-199
    // # This subroutine must be used after the principal discount has been set
    // if not self.principal_discount:
    intc_0 // 0
    bytec 19 // "principal_discount"
    app_global_get_ex
    assert // check self.principal_discount exists
    bnz asset_config_after_if_else@23
    // smart_contracts/base_d_asa/contract.py:200
    // assert interest_rate > UInt64(0), err.INVALID_INTEREST_RATE
    dig 12
    assert // Interest rate is not properly defined

asset_config_after_if_else@23:
    // smart_contracts/base_d_asa/contract.py:203
    // self.interest_rate = interest_rate
    bytec 26 // "interest_rate"
    dig 13
    app_global_put
    // smart_contracts/fixed_coupon_bond/contract.py:48
    // assert coupon_rates.length, err.INVALID_COUPON_RATES
    dig 3
    dup
    assert // Coupon rates are not properly defined
    // smart_contracts/base_d_asa/contract.py:209
    // self.total_coupons = coupon_rates.length
    bytec 5 // "total_coupons"
    dig 1
    app_global_put
    // smart_contracts/base_d_asa/contract.py:210
    // if self.total_coupons:
    bz asset_config_after_if_else@31
    // smart_contracts/base_d_asa/contract.py:211
    // self.coupon_rates.value = coupon_rates.copy()
    bytec 15 // 0x636f75706f6e5261746573
    box_del
    pop
    bytec 15 // 0x636f75706f6e5261746573
    dig 5
    box_put

asset_config_after_if_else@31:
    // smart_contracts/base_d_asa/contract.py:215
    // time_events.length == self.total_coupons + cfg.TIME_SCHEDULE_LIMITS
    intc_0 // 0
    bytec 5 // "total_coupons"
    app_global_get_ex
    assert // check self.total_coupons exists
    pushint 4
    +
    dig 2
    ==
    // smart_contracts/base_d_asa/contract.py:214-216
    // assert (
    //     time_events.length == self.total_coupons + cfg.TIME_SCHEDULE_LIMITS
    // ), err.INVALID_TIME_EVENTS_LENGTH
    assert // Time events length is invalid
    // smart_contracts/base_d_asa/contract.py:498
    // self.assert_time_events_sorted(time_events)
    dig 2
    callsub assert_time_events_sorted
    // smart_contracts/base_d_asa/contract.py:238
    // self.time_events.value = time_events.copy()
    bytec 10 // 0x74696d654576656e7473
    box_del
    pop
    bytec 10 // 0x74696d654576656e7473
    dig 1
    box_put
    // smart_contracts/base_d_asa/contract.py:239-241
    // self.primary_distribution_opening_date = time_events[
    //     cfg.PRIMARY_DISTRIBUTION_OPENING_DATE_IDX
    // ]
    dup
    extract 2 0
    bury 17
    dup
    pushint 2
    extract_uint64
    // smart_contracts/base_d_asa/contract.py:239
    // self.primary_distribution_opening_date = time_events[
    bytec 9 // "primary_distribution_opening_date"
    // smart_contracts/base_d_asa/contract.py:239-241
    // self.primary_distribution_opening_date = time_events[
    //     cfg.PRIMARY_DISTRIBUTION_OPENING_DATE_IDX
    // ]
    swap
    app_global_put
    // smart_contracts/base_d_asa/contract.py:242-244
    // self.primary_distribution_closure_date = time_events[
    //     cfg.PRIMARY_DISTRIBUTION_CLOSURE_DATE_IDX
    // ]
    dup
    pushint 10
    extract_uint64
    // smart_contracts/base_d_asa/contract.py:242
    // self.primary_distribution_closure_date = time_events[
    bytec 20 // "primary_distribution_closure_date"
    // smart_contracts/base_d_asa/contract.py:242-244
    // self.primary_distribution_closure_date = time_events[
    //     cfg.PRIMARY_DISTRIBUTION_CLOSURE_DATE_IDX
    // ]
    swap
    app_global_put
    // smart_contracts/base_d_asa/contract.py:245
    // self.issuance_date = time_events[cfg.ISSUANCE_DATE_IDX]
    dup
    pushint 18
    extract_uint64
    bytec 6 // "issuance_date"
    swap
    app_global_put
    // smart_contracts/base_d_asa/contract.py:247-248
    // # Some D-ASA may not have a maturity date (e.g., perpetuals)
    // if time_events.length == self.total_coupons + cfg.TIME_SCHEDULE_LIMITS:
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    bury 16
    intc_0 // 0
    bytec 5 // "total_coupons"
    app_global_get_ex
    assert // check self.total_coupons exists
    pushint 4
    +
    ==
    bz asset_config_after_if_else@37
    // smart_contracts/base_d_asa/contract.py:249
    // self.maturity_date = time_events[cfg.MATURITY_DATE_IDX]
    dig 14
    intc_1 // 1
    -
    intc_3 // 8
    *
    dig 16
    swap
    extract_uint64
    bytec 7 // "maturity_date"
    swap
    app_global_put

asset_config_after_if_else@37:
    // smart_contracts/base_d_asa/contract.py:252
    // assert not time_periods.length, err.INVALID_TIME_PERIODS
    dup
    !
    assert // Time periods are not properly defined
    // smart_contracts/base_d_asa/contract.py:505
    // self.status = UInt64(cfg.STATUS_ACTIVE)
    bytec_2 // "status"
    pushint 100
    app_global_put
    // smart_contracts/base_d_asa/contract.py:423
    // @arc4.abimethod
    intc_1 // 1
    return

asset_config_bool_false@16:
    intc_0 // 0
    b asset_config_bool_merge@17

asset_config_bool_false@4:
    intc_0 // 0
    b asset_config_bool_merge@5


// smart_contracts.base_d_asa.contract.BaseDAsa.set_secondary_time_events[routing]() -> void:
set_secondary_time_events:
    intc_0 // 0
    // smart_contracts/base_d_asa/contract.py:507
    // @arc4.abimethod
    txna ApplicationArgs 1
    dupn 2
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    dup
    intc_3 // 8
    *
    pushint 2
    +
    uncover 2
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<uint64>
    // smart_contracts/base_d_asa/contract.py:528
    // self.assert_caller_is_arranger()
    callsub assert_caller_is_arranger
    // smart_contracts/base_d_asa/contract.py:103
    // return self.status == cfg.STATUS_ENDED
    intc_0 // 0
    bytec_2 // "status"
    app_global_get_ex
    assert // check self.status exists
    intc 6 // 200
    ==
    // smart_contracts/base_d_asa/contract.py:529
    // assert not self.status_is_ended(), err.UNAUTHORIZED
    !
    assert // Not authorized
    // smart_contracts/base_d_asa/contract.py:530
    // self.assert_is_not_defaulted()
    callsub assert_is_not_defaulted
    // smart_contracts/base_d_asa/contract.py:532
    // assert secondary_market_time_events.length >= 1, err.INVALID_TIME_EVENTS_LENGTH
    dup
    assert // Time events length is invalid
    // smart_contracts/base_d_asa/contract.py:533
    // if secondary_market_time_events.length > 1:
    intc_1 // 1
    >
    bz set_secondary_time_events_after_if_else@3
    // smart_contracts/base_d_asa/contract.py:534
    // self.assert_time_events_sorted(secondary_market_time_events)
    dup
    callsub assert_time_events_sorted
    bury 1

set_secondary_time_events_after_if_else@3:
    // smart_contracts/base_d_asa/contract.py:536
    // self.issuance_date
    intc_0 // 0
    bytec 6 // "issuance_date"
    app_global_get_ex
    assert // check self.issuance_date exists
    // smart_contracts/base_d_asa/contract.py:537
    // <= secondary_market_time_events[cfg.SECONDARY_MARKET_OPENING_DATE_IDX]
    dig 1
    dup
    extract 2 0
    bury 4
    pushint 2
    extract_uint64
    // smart_contracts/base_d_asa/contract.py:536-537
    // self.issuance_date
    // <= secondary_market_time_events[cfg.SECONDARY_MARKET_OPENING_DATE_IDX]
    swap
    dig 1
    <=
    // smart_contracts/base_d_asa/contract.py:535-538
    // assert (
    //     self.issuance_date
    //     <= secondary_market_time_events[cfg.SECONDARY_MARKET_OPENING_DATE_IDX]
    // ), err.INVALID_SECONDARY_OPENING_DATE
    assert // Invalid secondary market opening date
    // smart_contracts/base_d_asa/contract.py:539
    // self.secondary_market_opening_date = secondary_market_time_events[
    bytec 13 // "secondary_market_opening_date"
    // smart_contracts/base_d_asa/contract.py:539-541
    // self.secondary_market_opening_date = secondary_market_time_events[
    //     cfg.SECONDARY_MARKET_OPENING_DATE_IDX
    // ]
    swap
    app_global_put
    // smart_contracts/base_d_asa/contract.py:542
    // if self.maturity_date:
    intc_0 // 0
    bytec 7 // "maturity_date"
    app_global_get_ex
    assert // check self.maturity_date exists
    bz set_secondary_time_events_after_if_else@5
    // smart_contracts/base_d_asa/contract.py:544
    // self.maturity_date
    intc_0 // 0
    bytec 7 // "maturity_date"
    app_global_get_ex
    assert // check self.maturity_date exists
    // smart_contracts/base_d_asa/contract.py:545
    // >= secondary_market_time_events[cfg.SECONDARY_MARKET_CLOSURE_DATE_IDX]
    dig 1
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_1 // 1
    -
    intc_3 // 8
    *
    dig 3
    swap
    extract_uint64
    // smart_contracts/base_d_asa/contract.py:544-545
    // self.maturity_date
    // >= secondary_market_time_events[cfg.SECONDARY_MARKET_CLOSURE_DATE_IDX]
    swap
    dig 1
    >=
    // smart_contracts/base_d_asa/contract.py:543-546
    // assert (
    //     self.maturity_date
    //     >= secondary_market_time_events[cfg.SECONDARY_MARKET_CLOSURE_DATE_IDX]
    // ), err.INVALID_SECONDARY_CLOSURE_DATE
    assert // Invalid secondary market closure date
    // smart_contracts/base_d_asa/contract.py:547
    // self.secondary_market_closure_date = secondary_market_time_events[
    bytec 14 // "secondary_market_closure_date"
    // smart_contracts/base_d_asa/contract.py:547-549
    // self.secondary_market_closure_date = secondary_market_time_events[
    //     cfg.SECONDARY_MARKET_CLOSURE_DATE_IDX
    // ]
    swap
    app_global_put

set_secondary_time_events_after_if_else@5:
    // smart_contracts/base_d_asa/contract.py:551
    // secondary_market_opening_date=self.secondary_market_opening_date,
    intc_0 // 0
    bytec 13 // "secondary_market_opening_date"
    app_global_get_ex
    assert // check self.secondary_market_opening_date exists
    // smart_contracts/base_d_asa/contract.py:552
    // secondary_market_closure_date=self.secondary_market_closure_date,
    intc_0 // 0
    bytec 14 // "secondary_market_closure_date"
    app_global_get_ex
    assert // check self.secondary_market_closure_date exists
    // smart_contracts/base_d_asa/contract.py:550-553
    // return typ.SecondaryMarketSchedule(
    //     secondary_market_opening_date=self.secondary_market_opening_date,
    //     secondary_market_closure_date=self.secondary_market_closure_date,
    // )
    swap
    itob
    swap
    itob
    concat
    // smart_contracts/base_d_asa/contract.py:507
    // @arc4.abimethod
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.base_d_asa.contract.BaseDAsa.assign_role[routing]() -> void:
assign_role:
    // smart_contracts/base_d_asa/contract.py:555
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    txna ApplicationArgs 3
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    pushint 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    swap
    // smart_contracts/base_d_asa/contract.py:576
    // self.assert_caller_is_arranger()
    callsub assert_caller_is_arranger
    // smart_contracts/base_d_asa/contract.py:577
    // self.assert_is_not_defaulted()
    callsub assert_is_not_defaulted
    // smart_contracts/base_d_asa/contract.py:578
    // assert role.as_uint64() in (
    btoi
    dup
    // smart_contracts/base_d_asa/contract.py:579
    // UInt64(cst.ROLE_ARRANGER),
    pushint 20
    // smart_contracts/base_d_asa/contract.py:578-585
    // assert role.as_uint64() in (
    //     UInt64(cst.ROLE_ARRANGER),
    //     UInt64(cst.ROLE_ACCOUNT_MANAGER),
    //     UInt64(cst.ROLE_PRIMARY_DEALER),
    //     UInt64(cst.ROLE_TRUSTEE),
    //     UInt64(cst.ROLE_AUTHORITY),
    //     UInt64(cst.ROLE_INTEREST_ORACLE),
    // ), err.INVALID_ROLE
    ==
    bnz assign_role_bool_true@7
    dup
    // smart_contracts/base_d_asa/contract.py:580
    // UInt64(cst.ROLE_ACCOUNT_MANAGER),
    pushint 40
    // smart_contracts/base_d_asa/contract.py:578-585
    // assert role.as_uint64() in (
    //     UInt64(cst.ROLE_ARRANGER),
    //     UInt64(cst.ROLE_ACCOUNT_MANAGER),
    //     UInt64(cst.ROLE_PRIMARY_DEALER),
    //     UInt64(cst.ROLE_TRUSTEE),
    //     UInt64(cst.ROLE_AUTHORITY),
    //     UInt64(cst.ROLE_INTEREST_ORACLE),
    // ), err.INVALID_ROLE
    ==
    bnz assign_role_bool_true@7
    dup
    // smart_contracts/base_d_asa/contract.py:581
    // UInt64(cst.ROLE_PRIMARY_DEALER),
    pushint 50
    // smart_contracts/base_d_asa/contract.py:578-585
    // assert role.as_uint64() in (
    //     UInt64(cst.ROLE_ARRANGER),
    //     UInt64(cst.ROLE_ACCOUNT_MANAGER),
    //     UInt64(cst.ROLE_PRIMARY_DEALER),
    //     UInt64(cst.ROLE_TRUSTEE),
    //     UInt64(cst.ROLE_AUTHORITY),
    //     UInt64(cst.ROLE_INTEREST_ORACLE),
    // ), err.INVALID_ROLE
    ==
    bnz assign_role_bool_true@7
    dup
    // smart_contracts/base_d_asa/contract.py:582
    // UInt64(cst.ROLE_TRUSTEE),
    pushint 60
    // smart_contracts/base_d_asa/contract.py:578-585
    // assert role.as_uint64() in (
    //     UInt64(cst.ROLE_ARRANGER),
    //     UInt64(cst.ROLE_ACCOUNT_MANAGER),
    //     UInt64(cst.ROLE_PRIMARY_DEALER),
    //     UInt64(cst.ROLE_TRUSTEE),
    //     UInt64(cst.ROLE_AUTHORITY),
    //     UInt64(cst.ROLE_INTEREST_ORACLE),
    // ), err.INVALID_ROLE
    ==
    bnz assign_role_bool_true@7
    dup
    // smart_contracts/base_d_asa/contract.py:583
    // UInt64(cst.ROLE_AUTHORITY),
    pushint 70
    // smart_contracts/base_d_asa/contract.py:578-585
    // assert role.as_uint64() in (
    //     UInt64(cst.ROLE_ARRANGER),
    //     UInt64(cst.ROLE_ACCOUNT_MANAGER),
    //     UInt64(cst.ROLE_PRIMARY_DEALER),
    //     UInt64(cst.ROLE_TRUSTEE),
    //     UInt64(cst.ROLE_AUTHORITY),
    //     UInt64(cst.ROLE_INTEREST_ORACLE),
    // ), err.INVALID_ROLE
    ==
    bnz assign_role_bool_true@7
    dup
    // smart_contracts/base_d_asa/contract.py:584
    // UInt64(cst.ROLE_INTEREST_ORACLE),
    pushint 80
    // smart_contracts/base_d_asa/contract.py:578-585
    // assert role.as_uint64() in (
    //     UInt64(cst.ROLE_ARRANGER),
    //     UInt64(cst.ROLE_ACCOUNT_MANAGER),
    //     UInt64(cst.ROLE_PRIMARY_DEALER),
    //     UInt64(cst.ROLE_TRUSTEE),
    //     UInt64(cst.ROLE_AUTHORITY),
    //     UInt64(cst.ROLE_INTEREST_ORACLE),
    // ), err.INVALID_ROLE
    ==
    bz assign_role_bool_false@8

assign_role_bool_true@7:
    intc_1 // 1

assign_role_bool_merge@9:
    // smart_contracts/base_d_asa/contract.py:578-585
    // assert role.as_uint64() in (
    //     UInt64(cst.ROLE_ARRANGER),
    //     UInt64(cst.ROLE_ACCOUNT_MANAGER),
    //     UInt64(cst.ROLE_PRIMARY_DEALER),
    //     UInt64(cst.ROLE_TRUSTEE),
    //     UInt64(cst.ROLE_AUTHORITY),
    //     UInt64(cst.ROLE_INTEREST_ORACLE),
    // ), err.INVALID_ROLE
    assert // Invalid role identifier
    // smart_contracts/base_d_asa/contract.py:587
    // case UInt64(cst.ROLE_ARRANGER):
    pushints 20 40 50 60 70 80
    // smart_contracts/base_d_asa/contract.py:586-609
    // match role.as_uint64():
    //     case UInt64(cst.ROLE_ARRANGER):
    //         self.arranger.value = role_address
    //     case UInt64(cst.ROLE_ACCOUNT_MANAGER):
    //         assert (
    //             role_address not in self.account_manager
    //         ), err.INVALID_ROLE_ADDRESS
    //         self.account_manager[role_address] = typ.RoleConfig.from_bytes(config)
    //     case UInt64(cst.ROLE_PRIMARY_DEALER):
    //         assert role_address not in self.primary_dealer, err.INVALID_ROLE_ADDRESS
    //         self.primary_dealer[role_address] = typ.RoleConfig.from_bytes(config)
    //     case UInt64(cst.ROLE_TRUSTEE):
    //         assert role_address not in self.trustee, err.INVALID_ROLE_ADDRESS
    //         self.trustee[role_address] = typ.RoleConfig.from_bytes(config)
    //     case UInt64(cst.ROLE_AUTHORITY):
    //         assert role_address not in self.authority, err.INVALID_ROLE_ADDRESS
    //         self.authority[role_address] = typ.RoleConfig.from_bytes(config)
    //     case UInt64(cst.ROLE_INTEREST_ORACLE):
    //         assert (
    //             role_address not in self.interest_oracle
    //         ), err.INVALID_ROLE_ADDRESS
    //         self.interest_oracle[role_address] = typ.RoleConfig.from_bytes(config)
    //     case _:
    //         op.err()
    dig 6
    match assign_role_switch_case_0@10 assign_role_switch_case_1@11 assign_role_switch_case_2@12 assign_role_switch_case_3@13 assign_role_switch_case_4@14 assign_role_switch_case_5@15
    // smart_contracts/base_d_asa/contract.py:609
    // op.err()
    err

assign_role_switch_case_5@15:
    // smart_contracts/base_d_asa/contract.py:605
    // role_address not in self.interest_oracle
    bytec 35 // 0x52383023
    dig 3
    concat
    dup
    box_len
    bury 1
    !
    // smart_contracts/base_d_asa/contract.py:604-606
    // assert (
    //     role_address not in self.interest_oracle
    // ), err.INVALID_ROLE_ADDRESS
    assert // Invalid account role address
    // smart_contracts/base_d_asa/contract.py:607
    // self.interest_oracle[role_address] = typ.RoleConfig.from_bytes(config)
    dig 2
    box_put

assign_role_switch_case_next@17:
    // smart_contracts/base_d_asa/contract.py:610
    // return Global.latest_timestamp
    global LatestTimestamp
    // smart_contracts/base_d_asa/contract.py:555
    // @arc4.abimethod
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

assign_role_switch_case_4@14:
    // smart_contracts/base_d_asa/contract.py:601
    // assert role_address not in self.authority, err.INVALID_ROLE_ADDRESS
    bytec 28 // 0x52373023
    dig 3
    concat
    dup
    box_len
    bury 1
    !
    assert // Invalid account role address
    // smart_contracts/base_d_asa/contract.py:602
    // self.authority[role_address] = typ.RoleConfig.from_bytes(config)
    dig 2
    box_put
    b assign_role_switch_case_next@17

assign_role_switch_case_3@13:
    // smart_contracts/base_d_asa/contract.py:598
    // assert role_address not in self.trustee, err.INVALID_ROLE_ADDRESS
    bytec 29 // 0x52363023
    dig 3
    concat
    dup
    box_len
    bury 1
    !
    assert // Invalid account role address
    // smart_contracts/base_d_asa/contract.py:599
    // self.trustee[role_address] = typ.RoleConfig.from_bytes(config)
    dig 2
    box_put
    b assign_role_switch_case_next@17

assign_role_switch_case_2@12:
    // smart_contracts/base_d_asa/contract.py:595
    // assert role_address not in self.primary_dealer, err.INVALID_ROLE_ADDRESS
    bytec 30 // 0x52353023
    dig 3
    concat
    dup
    box_len
    bury 1
    !
    assert // Invalid account role address
    // smart_contracts/base_d_asa/contract.py:596
    // self.primary_dealer[role_address] = typ.RoleConfig.from_bytes(config)
    dig 2
    box_put
    b assign_role_switch_case_next@17

assign_role_switch_case_1@11:
    // smart_contracts/base_d_asa/contract.py:591
    // role_address not in self.account_manager
    bytec 31 // 0x52343023
    dig 3
    concat
    dup
    box_len
    bury 1
    !
    // smart_contracts/base_d_asa/contract.py:590-592
    // assert (
    //     role_address not in self.account_manager
    // ), err.INVALID_ROLE_ADDRESS
    assert // Invalid account role address
    // smart_contracts/base_d_asa/contract.py:593
    // self.account_manager[role_address] = typ.RoleConfig.from_bytes(config)
    dig 2
    box_put
    b assign_role_switch_case_next@17

assign_role_switch_case_0@10:
    // smart_contracts/base_d_asa/contract.py:588
    // self.arranger.value = role_address
    bytec 16 // 0x52323023
    dig 3
    app_global_put
    b assign_role_switch_case_next@17

assign_role_bool_false@8:
    intc_0 // 0
    b assign_role_bool_merge@9


// smart_contracts.base_d_asa.contract.BaseDAsa.revoke_role[routing]() -> void:
revoke_role:
    // smart_contracts/base_d_asa/contract.py:612
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for arc4.uint8
    // smart_contracts/base_d_asa/contract.py:630
    // self.assert_caller_is_arranger()
    callsub assert_caller_is_arranger
    // smart_contracts/base_d_asa/contract.py:631
    // self.assert_is_not_defaulted()
    callsub assert_is_not_defaulted
    // smart_contracts/base_d_asa/contract.py:632
    // assert role.as_uint64() in (
    btoi
    dup
    // smart_contracts/base_d_asa/contract.py:633
    // UInt64(cst.ROLE_ACCOUNT_MANAGER),
    pushint 40
    // smart_contracts/base_d_asa/contract.py:632-638
    // assert role.as_uint64() in (
    //     UInt64(cst.ROLE_ACCOUNT_MANAGER),
    //     UInt64(cst.ROLE_PRIMARY_DEALER),
    //     UInt64(cst.ROLE_TRUSTEE),
    //     UInt64(cst.ROLE_AUTHORITY),
    //     UInt64(cst.ROLE_INTEREST_ORACLE),
    // ), err.INVALID_ROLE
    ==
    bnz revoke_role_bool_true@6
    dup
    // smart_contracts/base_d_asa/contract.py:634
    // UInt64(cst.ROLE_PRIMARY_DEALER),
    pushint 50
    // smart_contracts/base_d_asa/contract.py:632-638
    // assert role.as_uint64() in (
    //     UInt64(cst.ROLE_ACCOUNT_MANAGER),
    //     UInt64(cst.ROLE_PRIMARY_DEALER),
    //     UInt64(cst.ROLE_TRUSTEE),
    //     UInt64(cst.ROLE_AUTHORITY),
    //     UInt64(cst.ROLE_INTEREST_ORACLE),
    // ), err.INVALID_ROLE
    ==
    bnz revoke_role_bool_true@6
    dup
    // smart_contracts/base_d_asa/contract.py:635
    // UInt64(cst.ROLE_TRUSTEE),
    pushint 60
    // smart_contracts/base_d_asa/contract.py:632-638
    // assert role.as_uint64() in (
    //     UInt64(cst.ROLE_ACCOUNT_MANAGER),
    //     UInt64(cst.ROLE_PRIMARY_DEALER),
    //     UInt64(cst.ROLE_TRUSTEE),
    //     UInt64(cst.ROLE_AUTHORITY),
    //     UInt64(cst.ROLE_INTEREST_ORACLE),
    // ), err.INVALID_ROLE
    ==
    bnz revoke_role_bool_true@6
    dup
    // smart_contracts/base_d_asa/contract.py:636
    // UInt64(cst.ROLE_AUTHORITY),
    pushint 70
    // smart_contracts/base_d_asa/contract.py:632-638
    // assert role.as_uint64() in (
    //     UInt64(cst.ROLE_ACCOUNT_MANAGER),
    //     UInt64(cst.ROLE_PRIMARY_DEALER),
    //     UInt64(cst.ROLE_TRUSTEE),
    //     UInt64(cst.ROLE_AUTHORITY),
    //     UInt64(cst.ROLE_INTEREST_ORACLE),
    // ), err.INVALID_ROLE
    ==
    bnz revoke_role_bool_true@6
    dup
    // smart_contracts/base_d_asa/contract.py:637
    // UInt64(cst.ROLE_INTEREST_ORACLE),
    pushint 80
    // smart_contracts/base_d_asa/contract.py:632-638
    // assert role.as_uint64() in (
    //     UInt64(cst.ROLE_ACCOUNT_MANAGER),
    //     UInt64(cst.ROLE_PRIMARY_DEALER),
    //     UInt64(cst.ROLE_TRUSTEE),
    //     UInt64(cst.ROLE_AUTHORITY),
    //     UInt64(cst.ROLE_INTEREST_ORACLE),
    // ), err.INVALID_ROLE
    ==
    bz revoke_role_bool_false@7

revoke_role_bool_true@6:
    intc_1 // 1

revoke_role_bool_merge@8:
    // smart_contracts/base_d_asa/contract.py:632-638
    // assert role.as_uint64() in (
    //     UInt64(cst.ROLE_ACCOUNT_MANAGER),
    //     UInt64(cst.ROLE_PRIMARY_DEALER),
    //     UInt64(cst.ROLE_TRUSTEE),
    //     UInt64(cst.ROLE_AUTHORITY),
    //     UInt64(cst.ROLE_INTEREST_ORACLE),
    // ), err.INVALID_ROLE
    assert // Invalid role identifier
    // smart_contracts/base_d_asa/contract.py:640-641
    // # Arranger role can not be revoked (just rotated)
    // case UInt64(cst.ROLE_ACCOUNT_MANAGER):
    pushints 40 50 60 70 80
    // smart_contracts/base_d_asa/contract.py:639-657
    // match role.as_uint64():
    //     # Arranger role can not be revoked (just rotated)
    //     case UInt64(cst.ROLE_ACCOUNT_MANAGER):
    //         assert role_address in self.account_manager, err.INVALID_ROLE_ADDRESS
    //         del self.account_manager[role_address]
    //     case UInt64(cst.ROLE_PRIMARY_DEALER):
    //         assert role_address in self.primary_dealer, err.INVALID_ROLE_ADDRESS
    //         del self.primary_dealer[role_address]
    //     case UInt64(cst.ROLE_TRUSTEE):
    //         assert role_address in self.trustee, err.INVALID_ROLE_ADDRESS
    //         del self.trustee[role_address]
    //     case UInt64(cst.ROLE_AUTHORITY):
    //         assert role_address in self.authority, err.INVALID_ROLE_ADDRESS
    //         del self.authority[role_address]
    //     case UInt64(cst.ROLE_INTEREST_ORACLE):
    //         assert role_address in self.interest_oracle, err.INVALID_ROLE_ADDRESS
    //         del self.interest_oracle[role_address]
    //     case _:
    //         op.err()
    dig 5
    match revoke_role_switch_case_0@9 revoke_role_switch_case_1@10 revoke_role_switch_case_2@11 revoke_role_switch_case_3@12 revoke_role_switch_case_4@13
    // smart_contracts/base_d_asa/contract.py:657
    // op.err()
    err

revoke_role_switch_case_4@13:
    // smart_contracts/base_d_asa/contract.py:654
    // assert role_address in self.interest_oracle, err.INVALID_ROLE_ADDRESS
    bytec 35 // 0x52383023
    dig 2
    concat
    dup
    box_len
    bury 1
    assert // Invalid account role address
    // smart_contracts/base_d_asa/contract.py:655
    // del self.interest_oracle[role_address]
    box_del
    pop

revoke_role_switch_case_next@15:
    // smart_contracts/base_d_asa/contract.py:658
    // return Global.latest_timestamp
    global LatestTimestamp
    // smart_contracts/base_d_asa/contract.py:612
    // @arc4.abimethod
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

revoke_role_switch_case_3@12:
    // smart_contracts/base_d_asa/contract.py:651
    // assert role_address in self.authority, err.INVALID_ROLE_ADDRESS
    bytec 28 // 0x52373023
    dig 2
    concat
    dup
    box_len
    bury 1
    assert // Invalid account role address
    // smart_contracts/base_d_asa/contract.py:652
    // del self.authority[role_address]
    box_del
    pop
    b revoke_role_switch_case_next@15

revoke_role_switch_case_2@11:
    // smart_contracts/base_d_asa/contract.py:648
    // assert role_address in self.trustee, err.INVALID_ROLE_ADDRESS
    bytec 29 // 0x52363023
    dig 2
    concat
    dup
    box_len
    bury 1
    assert // Invalid account role address
    // smart_contracts/base_d_asa/contract.py:649
    // del self.trustee[role_address]
    box_del
    pop
    b revoke_role_switch_case_next@15

revoke_role_switch_case_1@10:
    // smart_contracts/base_d_asa/contract.py:645
    // assert role_address in self.primary_dealer, err.INVALID_ROLE_ADDRESS
    bytec 30 // 0x52353023
    dig 2
    concat
    dup
    box_len
    bury 1
    assert // Invalid account role address
    // smart_contracts/base_d_asa/contract.py:646
    // del self.primary_dealer[role_address]
    box_del
    pop
    b revoke_role_switch_case_next@15

revoke_role_switch_case_0@9:
    // smart_contracts/base_d_asa/contract.py:642
    // assert role_address in self.account_manager, err.INVALID_ROLE_ADDRESS
    bytec 31 // 0x52343023
    dig 2
    concat
    dup
    box_len
    bury 1
    assert // Invalid account role address
    // smart_contracts/base_d_asa/contract.py:643
    // del self.account_manager[role_address]
    box_del
    pop
    b revoke_role_switch_case_next@15

revoke_role_bool_false@7:
    intc_0 // 0
    b revoke_role_bool_merge@8


// smart_contracts.base_d_asa.contract.BaseDAsa.open_account[routing]() -> void:
open_account:
    // smart_contracts/base_d_asa/contract.py:660
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/base_d_asa/contract.py:680
    // self.assert_caller_is_account_manager()
    callsub assert_caller_is_account_manager
    // smart_contracts/base_d_asa/contract.py:103
    // return self.status == cfg.STATUS_ENDED
    intc_0 // 0
    bytec_2 // "status"
    app_global_get_ex
    assert // check self.status exists
    intc 6 // 200
    ==
    // smart_contracts/base_d_asa/contract.py:681
    // assert not self.status_is_ended(), err.UNAUTHORIZED
    !
    assert // Not authorized
    // smart_contracts/base_d_asa/contract.py:682
    // self.assert_is_not_defaulted()
    callsub assert_is_not_defaulted
    // smart_contracts/base_d_asa/contract.py:683
    // self.assert_is_not_suspended()
    callsub assert_is_not_suspended
    // smart_contracts/base_d_asa/contract.py:684
    // assert holding_address not in self.account, err.INVALID_HOLDING_ADDRESS
    bytec_1 // 0x52333023
    uncover 2
    concat
    dup
    box_len
    bury 1
    !
    assert // Invalid account holding address
    // smart_contracts/base_d_asa/contract.py:688
    // units=UInt64(0),
    intc_0 // 0
    // smart_contracts/base_d_asa/contract.py:686-692
    // self.account[holding_address] = typ.AccountInfo(
    //     payment_address=payment_address,
    //     units=UInt64(0),
    //     unit_value=UInt64(0),
    //     paid_coupons=UInt64(0),
    //     suspended=False,
    // )
    itob
    uncover 2
    dig 1
    concat
    dig 1
    concat
    swap
    concat
    bytec 27 // 0x00
    concat
    box_put
    // smart_contracts/base_d_asa/contract.py:693
    // return Global.latest_timestamp
    global LatestTimestamp
    // smart_contracts/base_d_asa/contract.py:660
    // @arc4.abimethod
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.base_d_asa.contract.BaseDAsa.close_account[routing]() -> void:
close_account:
    // smart_contracts/base_d_asa/contract.py:695
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/base_d_asa/contract.py:711
    // self.assert_caller_is_account_manager()
    callsub assert_caller_is_account_manager
    // smart_contracts/base_d_asa/contract.py:712
    // self.assert_is_not_defaulted()
    callsub assert_is_not_defaulted
    // smart_contracts/base_d_asa/contract.py:160
    // assert holding_address in self.account, err.INVALID_HOLDING_ADDRESS
    bytec_1 // 0x52333023
    swap
    concat
    dup
    box_len
    bury 1
    assert // Invalid account holding address
    // smart_contracts/base_d_asa/contract.py:715
    // closed_units = self.account[holding_address].units
    dup
    box_get
    pop
    intc_2 // 32
    extract_uint64
    // smart_contracts/base_d_asa/contract.py:716
    // del self.account[holding_address]
    swap
    box_del
    pop
    // smart_contracts/base_d_asa/contract.py:717
    // self.circulating_units -= closed_units
    intc_0 // 0
    bytec 4 // "circulating_units"
    app_global_get_ex
    assert // check self.circulating_units exists
    dig 1
    -
    bytec 4 // "circulating_units"
    swap
    app_global_put
    // smart_contracts/base_d_asa/contract.py:718
    // self.end_if_no_circulating_units()
    callsub end_if_no_circulating_units
    // smart_contracts/base_d_asa/contract.py:719
    // return closed_units, Global.latest_timestamp
    global LatestTimestamp
    // smart_contracts/base_d_asa/contract.py:695
    // @arc4.abimethod
    swap
    itob
    swap
    itob
    concat
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.base_d_asa.contract.BaseDAsa.primary_distribution[routing]() -> void:
primary_distribution:
    intc_0 // 0
    bytec_3 // ""
    // smart_contracts/base_d_asa/contract.py:721
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/base_d_asa/contract.py:100
    // return self.status == cfg.STATUS_ACTIVE
    intc_0 // 0
    bytec_2 // "status"
    app_global_get_ex
    assert // check self.status exists
    pushint 100
    ==
    // smart_contracts/base_d_asa/contract.py:259-262
    // self.status_is_active()
    // and self.primary_distribution_opening_date
    // <= Global.latest_timestamp
    // < self.primary_distribution_closure_date
    bz primary_distribution_bool_false@5
    // smart_contracts/base_d_asa/contract.py:260
    // and self.primary_distribution_opening_date
    intc_0 // 0
    bytec 9 // "primary_distribution_opening_date"
    app_global_get_ex
    assert // check self.primary_distribution_opening_date exists
    // smart_contracts/base_d_asa/contract.py:261
    // <= Global.latest_timestamp
    global LatestTimestamp
    dup
    bury 5
    // smart_contracts/base_d_asa/contract.py:260-261
    // and self.primary_distribution_opening_date
    // <= Global.latest_timestamp
    <=
    // smart_contracts/base_d_asa/contract.py:260-262
    // and self.primary_distribution_opening_date
    // <= Global.latest_timestamp
    // < self.primary_distribution_closure_date
    bz primary_distribution_bool_false@5
    // smart_contracts/base_d_asa/contract.py:262
    // < self.primary_distribution_closure_date
    intc_0 // 0
    bytec 20 // "primary_distribution_closure_date"
    app_global_get_ex
    assert // check self.primary_distribution_closure_date exists
    // smart_contracts/base_d_asa/contract.py:261-262
    // <= Global.latest_timestamp
    // < self.primary_distribution_closure_date
    dig 3
    >
    // smart_contracts/base_d_asa/contract.py:260-262
    // and self.primary_distribution_opening_date
    // <= Global.latest_timestamp
    // < self.primary_distribution_closure_date
    bz primary_distribution_bool_false@5
    intc_1 // 1

primary_distribution_bool_merge@6:
    // smart_contracts/base_d_asa/contract.py:258-263
    // assert (
    //     self.status_is_active()
    //     and self.primary_distribution_opening_date
    //     <= Global.latest_timestamp
    //     < self.primary_distribution_closure_date
    // ), err.PRIMARY_DISTRIBUTION_CLOSED
    assert // Primary distribution is closed
    // smart_contracts/base_d_asa/contract.py:126
    // caller in self.primary_dealer
    bytec 30 // 0x52353023
    // smart_contracts/base_d_asa/contract.py:124
    // caller = Txn.sender
    txn Sender
    // smart_contracts/base_d_asa/contract.py:126
    // caller in self.primary_dealer
    concat
    dup
    bury 5
    box_len
    bury 1
    // smart_contracts/base_d_asa/contract.py:126-129
    // caller in self.primary_dealer
    // and self.primary_dealer[caller].role_validity_start
    // <= Global.latest_timestamp
    // <= self.primary_dealer[caller].role_validity_end
    bz primary_distribution_bool_false@12
    // smart_contracts/base_d_asa/contract.py:127
    // and self.primary_dealer[caller].role_validity_start
    dig 3
    box_get
    assert // check self.primary_dealer entry exists
    intc_0 // 0
    extract_uint64
    // smart_contracts/base_d_asa/contract.py:128
    // <= Global.latest_timestamp
    global LatestTimestamp
    dup
    bury 5
    // smart_contracts/base_d_asa/contract.py:127-128
    // and self.primary_dealer[caller].role_validity_start
    // <= Global.latest_timestamp
    <=
    // smart_contracts/base_d_asa/contract.py:127-129
    // and self.primary_dealer[caller].role_validity_start
    // <= Global.latest_timestamp
    // <= self.primary_dealer[caller].role_validity_end
    bz primary_distribution_bool_false@12
    // smart_contracts/base_d_asa/contract.py:129
    // <= self.primary_dealer[caller].role_validity_end
    dig 3
    box_get
    assert // check self.primary_dealer entry exists
    intc_3 // 8
    extract_uint64
    // smart_contracts/base_d_asa/contract.py:128-129
    // <= Global.latest_timestamp
    // <= self.primary_dealer[caller].role_validity_end
    dig 3
    >=
    // smart_contracts/base_d_asa/contract.py:127-129
    // and self.primary_dealer[caller].role_validity_start
    // <= Global.latest_timestamp
    // <= self.primary_dealer[caller].role_validity_end
    bz primary_distribution_bool_false@12
    intc_1 // 1

primary_distribution_bool_merge@13:
    // smart_contracts/base_d_asa/contract.py:125-130
    // assert (
    //     caller in self.primary_dealer
    //     and self.primary_dealer[caller].role_validity_start
    //     <= Global.latest_timestamp
    //     <= self.primary_dealer[caller].role_validity_end
    // ), err.UNAUTHORIZED
    assert // Not authorized
    // smart_contracts/base_d_asa/contract.py:160
    // assert holding_address in self.account, err.INVALID_HOLDING_ADDRESS
    bytec_1 // 0x52333023
    dig 2
    concat
    dup
    box_len
    bury 1
    assert // Invalid account holding address
    // smart_contracts/base_d_asa/contract.py:749
    // self.assert_is_not_defaulted()
    callsub assert_is_not_defaulted
    // smart_contracts/base_d_asa/contract.py:750
    // self.assert_is_not_suspended()
    callsub assert_is_not_suspended
    // smart_contracts/base_d_asa/contract.py:751
    // assert units > 0, err.ZERO_UNITS
    dig 1
    dup
    assert // Can not distribute zero units
    // smart_contracts/base_d_asa/contract.py:752
    // assert self.circulating_units + units <= self.total_units, err.OVER_DISTRIBUTION
    intc_0 // 0
    bytec 4 // "circulating_units"
    app_global_get_ex
    assert // check self.circulating_units exists
    dig 1
    +
    intc_0 // 0
    bytec 12 // "total_units"
    app_global_get_ex
    assert // check self.total_units exists
    dig 1
    >=
    assert // Insufficient remaining D-ASA units
    // smart_contracts/base_d_asa/contract.py:754
    // self.circulating_units += units
    bytec 4 // "circulating_units"
    dig 1
    app_global_put
    // smart_contracts/base_d_asa/contract.py:755
    // self.account[holding_address].units += units
    dig 2
    box_get
    assert // check self.account entry exists
    intc_2 // 32
    extract_uint64
    uncover 2
    +
    itob
    dig 2
    intc_2 // 32
    uncover 2
    box_replace
    // smart_contracts/base_d_asa/contract.py:756
    // self.account[holding_address].unit_value = self.unit_value
    intc_0 // 0
    bytec 17 // "unit_value"
    app_global_get_ex
    assert // check self.unit_value exists
    itob
    uncover 2
    pushint 40
    uncover 2
    box_replace
    // smart_contracts/base_d_asa/contract.py:757
    // return self.total_units - self.circulating_units
    intc_0 // 0
    bytec 12 // "total_units"
    app_global_get_ex
    assert // check self.total_units exists
    swap
    -
    // smart_contracts/base_d_asa/contract.py:721
    // @arc4.abimethod
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

primary_distribution_bool_false@12:
    intc_0 // 0
    b primary_distribution_bool_merge@13

primary_distribution_bool_false@5:
    intc_0 // 0
    b primary_distribution_bool_merge@6


// smart_contracts.base_d_asa.contract.BaseDAsa.set_asset_suspension[routing]() -> void:
set_asset_suspension:
    // smart_contracts/base_d_asa/contract.py:759
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for arc4.bool
    intc_0 // 0
    getbit
    // smart_contracts/base_d_asa/contract.py:773
    // self.assert_caller_is_authority()
    callsub assert_caller_is_authority
    // smart_contracts/base_d_asa/contract.py:774
    // self.suspended = suspended
    bytec 21 // "suspended"
    swap
    app_global_put
    // smart_contracts/base_d_asa/contract.py:775
    // return Global.latest_timestamp
    global LatestTimestamp
    // smart_contracts/base_d_asa/contract.py:759
    // @arc4.abimethod
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.base_d_asa.contract.BaseDAsa.set_account_suspension[routing]() -> void:
set_account_suspension:
    // smart_contracts/base_d_asa/contract.py:777
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for arc4.bool
    intc_0 // 0
    getbit
    // smart_contracts/base_d_asa/contract.py:795
    // self.assert_caller_is_authority()
    callsub assert_caller_is_authority
    // smart_contracts/base_d_asa/contract.py:160
    // assert holding_address in self.account, err.INVALID_HOLDING_ADDRESS
    bytec_1 // 0x52333023
    uncover 2
    concat
    dup
    box_len
    bury 1
    assert // Invalid account holding address
    // smart_contracts/base_d_asa/contract.py:797
    // self.account[holding_address].suspended = suspended
    dup
    pushint 56
    intc_1 // 1
    box_extract
    intc_0 // 0
    uncover 3
    setbit
    pushint 56
    swap
    box_replace
    // smart_contracts/base_d_asa/contract.py:798
    // return Global.latest_timestamp
    global LatestTimestamp
    // smart_contracts/base_d_asa/contract.py:777
    // @arc4.abimethod
    itob
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.base_d_asa.contract.BaseDAsa.set_default_status[routing]() -> void:
set_default_status:
    bytec_3 // ""
    // smart_contracts/base_d_asa/contract.py:800
    // @arc4.abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_1 // 1
    ==
    assert // invalid number of bytes for arc4.bool
    intc_0 // 0
    getbit
    // smart_contracts/base_d_asa/contract.py:135
    // caller in self.trustee
    bytec 29 // 0x52363023
    // smart_contracts/base_d_asa/contract.py:133
    // caller = Txn.sender
    txn Sender
    // smart_contracts/base_d_asa/contract.py:135
    // caller in self.trustee
    concat
    dup
    box_len
    bury 1
    // smart_contracts/base_d_asa/contract.py:135-138
    // caller in self.trustee
    // and self.trustee[caller].role_validity_start
    // <= Global.latest_timestamp
    // <= self.trustee[caller].role_validity_end
    bz set_default_status_bool_false@5
    // smart_contracts/base_d_asa/contract.py:136
    // and self.trustee[caller].role_validity_start
    dup
    box_get
    assert // check self.trustee entry exists
    intc_0 // 0
    extract_uint64
    // smart_contracts/base_d_asa/contract.py:137
    // <= Global.latest_timestamp
    global LatestTimestamp
    dup
    bury 5
    // smart_contracts/base_d_asa/contract.py:136-137
    // and self.trustee[caller].role_validity_start
    // <= Global.latest_timestamp
    <=
    // smart_contracts/base_d_asa/contract.py:136-138
    // and self.trustee[caller].role_validity_start
    // <= Global.latest_timestamp
    // <= self.trustee[caller].role_validity_end
    bz set_default_status_bool_false@5
    // smart_contracts/base_d_asa/contract.py:138
    // <= self.trustee[caller].role_validity_end
    dup
    box_get
    assert // check self.trustee entry exists
    intc_3 // 8
    extract_uint64
    // smart_contracts/base_d_asa/contract.py:137-138
    // <= Global.latest_timestamp
    // <= self.trustee[caller].role_validity_end
    dig 3
    >=
    // smart_contracts/base_d_asa/contract.py:136-138
    // and self.trustee[caller].role_validity_start
    // <= Global.latest_timestamp
    // <= self.trustee[caller].role_validity_end
    bz set_default_status_bool_false@5
    intc_1 // 1

set_default_status_bool_merge@6:
    // smart_contracts/base_d_asa/contract.py:134-139
    // assert (
    //     caller in self.trustee
    //     and self.trustee[caller].role_validity_start
    //     <= Global.latest_timestamp
    //     <= self.trustee[caller].role_validity_end
    // ), err.UNAUTHORIZED
    assert // Not authorized
    // smart_contracts/base_d_asa/contract.py:812
    // self.defaulted = defaulted
    bytec 22 // "defaulted"
    dig 2
    app_global_put
    // smart_contracts/base_d_asa/contract.py:800
    // @arc4.abimethod
    intc_1 // 1
    return

set_default_status_bool_false@5:
    intc_0 // 0
    b set_default_status_bool_merge@6


// smart_contracts.base_d_asa.contract.BaseDAsa.get_asset_info[routing]() -> void:
get_asset_info:
    // smart_contracts/base_d_asa/contract.py:824
    // performance = UInt64(cst.PRF_PERFORMANT)
    intc_0 // 0
    // smart_contracts/base_d_asa/contract.py:825
    // if Global.latest_timestamp > self.maturity_date > 0:
    global LatestTimestamp
    intc_0 // 0
    bytec 7 // "maturity_date"
    app_global_get_ex
    swap
    dup
    cover 2
    cover 3
    assert // check self.maturity_date exists
    >
    bz get_asset_info_after_if_else@4
    dup
    bz get_asset_info_after_if_else@4
    // smart_contracts/base_d_asa/contract.py:826
    // performance = UInt64(cst.PRF_MATURED)
    pushint 4
    bury 2

get_asset_info_after_if_else@4:
    // smart_contracts/base_d_asa/contract.py:827-828
    // # The reference implementation has no grace or delinquency periods
    // if self.defaulted:
    intc_0 // 0
    bytec 22 // "defaulted"
    app_global_get_ex
    assert // check self.defaulted exists
    bz get_asset_info_after_if_else@6
    // smart_contracts/base_d_asa/contract.py:829
    // performance = UInt64(cst.PRF_DEFAULTED)
    pushint 3
    bury 2

get_asset_info_after_if_else@6:
    // smart_contracts/base_d_asa/contract.py:832
    // denomination_asset_id=self.denomination_asset_id,
    intc_0 // 0
    bytec 25 // "denomination_asset_id"
    app_global_get_ex
    assert // check self.denomination_asset_id exists
    // smart_contracts/base_d_asa/contract.py:833
    // settlement_asset_id=self.settlement_asset_id,
    intc_0 // 0
    bytec 8 // "settlement_asset_id"
    app_global_get_ex
    assert // check self.settlement_asset_id exists
    // smart_contracts/base_d_asa/contract.py:302
    // return self.circulating_units * self.unit_value
    intc_0 // 0
    bytec 4 // "circulating_units"
    app_global_get_ex
    assert // check self.circulating_units exists
    intc_0 // 0
    bytec 17 // "unit_value"
    app_global_get_ex
    assert // check self.unit_value exists
    dup2
    *
    // smart_contracts/base_d_asa/contract.py:836
    // day_count_convention=arc4.UInt8(self.day_count_convention),
    intc_0 // 0
    bytec 11 // "day_count_convention"
    app_global_get_ex
    assert // check self.day_count_convention exists
    itob
    dup
    bitlen
    intc_3 // 8
    <=
    assert // overflow
    extract 7 1
    // smart_contracts/base_d_asa/contract.py:837
    // principal_discount=arc4.UInt16(self.principal_discount),
    intc_0 // 0
    bytec 19 // "principal_discount"
    app_global_get_ex
    assert // check self.principal_discount exists
    itob
    dup
    bitlen
    pushint 16
    <=
    assert // overflow
    extract 6 2
    // smart_contracts/base_d_asa/contract.py:838
    // interest_rate=arc4.UInt16(self.interest_rate),
    intc_0 // 0
    bytec 26 // "interest_rate"
    app_global_get_ex
    assert // check self.interest_rate exists
    itob
    dup
    bitlen
    pushint 16
    <=
    assert // overflow
    extract 6 2
    // smart_contracts/base_d_asa/contract.py:839
    // total_supply=self.total_units,
    intc_0 // 0
    bytec 12 // "total_units"
    app_global_get_ex
    assert // check self.total_units exists
    // smart_contracts/base_d_asa/contract.py:841
    // primary_distribution_opening_date=self.primary_distribution_opening_date,
    intc_0 // 0
    bytec 9 // "primary_distribution_opening_date"
    app_global_get_ex
    assert // check self.primary_distribution_opening_date exists
    // smart_contracts/base_d_asa/contract.py:842
    // primary_distribution_closure_date=self.primary_distribution_closure_date,
    intc_0 // 0
    bytec 20 // "primary_distribution_closure_date"
    app_global_get_ex
    assert // check self.primary_distribution_closure_date exists
    // smart_contracts/base_d_asa/contract.py:843
    // issuance_date=self.issuance_date,
    intc_0 // 0
    bytec 6 // "issuance_date"
    app_global_get_ex
    assert // check self.issuance_date exists
    // smart_contracts/base_d_asa/contract.py:844
    // maturity_date=self.maturity_date,
    intc_0 // 0
    bytec 7 // "maturity_date"
    app_global_get_ex
    assert // check self.maturity_date exists
    // smart_contracts/base_d_asa/contract.py:845
    // suspended=self.suspended,
    intc_0 // 0
    bytec 21 // "suspended"
    app_global_get_ex
    assert // check self.suspended exists
    // smart_contracts/base_d_asa/contract.py:846
    // performance=arc4.UInt8(performance),
    dig 15
    itob
    dup
    bitlen
    intc_3 // 8
    <=
    assert // overflow
    extract 7 1
    // smart_contracts/base_d_asa/contract.py:831-847
    // return typ.AssetInfo(
    //     denomination_asset_id=self.denomination_asset_id,
    //     settlement_asset_id=self.settlement_asset_id,
    //     outstanding_principal=self.outstanding_principal(),
    //     unit_value=self.unit_value,
    //     day_count_convention=arc4.UInt8(self.day_count_convention),
    //     principal_discount=arc4.UInt16(self.principal_discount),
    //     interest_rate=arc4.UInt16(self.interest_rate),
    //     total_supply=self.total_units,
    //     circulating_supply=self.circulating_units,
    //     primary_distribution_opening_date=self.primary_distribution_opening_date,
    //     primary_distribution_closure_date=self.primary_distribution_closure_date,
    //     issuance_date=self.issuance_date,
    //     maturity_date=self.maturity_date,
    //     suspended=self.suspended,
    //     performance=arc4.UInt8(performance),
    // )
    uncover 14
    itob
    uncover 14
    itob
    concat
    uncover 11
    itob
    concat
    uncover 11
    itob
    concat
    uncover 10
    concat
    uncover 9
    concat
    uncover 8
    concat
    uncover 7
    itob
    concat
    uncover 7
    itob
    concat
    uncover 6
    itob
    concat
    uncover 5
    itob
    concat
    uncover 4
    itob
    concat
    uncover 3
    itob
    concat
    bytec 27 // 0x00
    intc_0 // 0
    uncover 4
    setbit
    concat
    swap
    concat
    // smart_contracts/base_d_asa/contract.py:814
    // @arc4.abimethod(readonly=True)
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.base_d_asa.contract.BaseDAsa.get_account_info[routing]() -> void:
get_account_info:
    // smart_contracts/base_d_asa/contract.py:849
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/base_d_asa/contract.py:160
    // assert holding_address in self.account, err.INVALID_HOLDING_ADDRESS
    bytec_1 // 0x52333023
    swap
    concat
    dup
    box_len
    bury 1
    assert // Invalid account holding address
    // smart_contracts/base_d_asa/contract.py:864
    // return self.account[holding_address]
    box_get
    pop
    // smart_contracts/base_d_asa/contract.py:849
    // @arc4.abimethod(readonly=True)
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.base_d_asa.contract.BaseDAsa.get_time_events[routing]() -> void:
get_time_events:
    // smart_contracts/base_d_asa/contract.py:874
    // time_events = typ.TimeEvents()
    bytec 34 // 0x0000
    // smart_contracts/base_d_asa/contract.py:100
    // return self.status == cfg.STATUS_ACTIVE
    intc_0 // 0
    bytec_2 // "status"
    app_global_get_ex
    assert // check self.status exists
    pushint 100
    ==
    // smart_contracts/base_d_asa/contract.py:875
    // if self.status_is_active():
    bz get_time_events_after_if_else@3
    // smart_contracts/base_d_asa/contract.py:876
    // time_events = self.time_events.value.copy()
    bytec 10 // 0x74696d654576656e7473
    box_get
    swap
    bury 2
    assert // check self.time_events exists

get_time_events_after_if_else@3:
    // smart_contracts/base_d_asa/contract.py:866
    // @arc4.abimethod(readonly=True)
    bytec_0 // 0x151f7c75
    dig 1
    concat
    log
    intc_1 // 1
    return


// smart_contracts.base_d_asa.contract.BaseDAsa.get_secondary_market_schedule[routing]() -> void:
get_secondary_market_schedule:
    // smart_contracts/base_d_asa/contract.py:888
    // (self.secondary_market_opening_date, self.secondary_market_closure_date)
    intc_0 // 0
    bytec 13 // "secondary_market_opening_date"
    app_global_get_ex
    assert // check self.secondary_market_opening_date exists
    intc_0 // 0
    bytec 14 // "secondary_market_closure_date"
    app_global_get_ex
    assert // check self.secondary_market_closure_date exists
    // smart_contracts/base_d_asa/contract.py:887-889
    // return typ.TimeEvents(
    //     (self.secondary_market_opening_date, self.secondary_market_closure_date)
    // )
    swap
    itob
    pushbytes 0x0002
    swap
    concat
    swap
    itob
    concat
    // smart_contracts/base_d_asa/contract.py:879
    // @arc4.abimethod(readonly=True)
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.base_d_asa.contract.BaseDAsa.get_asset_metadata[routing]() -> void:
get_asset_metadata:
    // smart_contracts/base_d_asa/contract.py:900
    // return typ.AssetMetadata.from_bytes(self.metadata)
    intc_0 // 0
    bytec 18 // "metadata"
    app_global_get_ex
    assert // check self.metadata exists
    // smart_contracts/base_d_asa/contract.py:891
    // @arc4.abimethod(readonly=True)
    bytec_0 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts.fixed_coupon_bond.contract.FixedCouponBond.count_due_coupons() -> uint64:
count_due_coupons:
    // smart_contracts/fixed_coupon_bond/contract.py:50
    // def count_due_coupons(self) -> UInt64:
    proto 0 1
    bytec_3 // ""
    // smart_contracts/fixed_coupon_bond/contract.py:51
    // current_ts = Global.latest_timestamp
    global LatestTimestamp
    dup
    // smart_contracts/fixed_coupon_bond/contract.py:52
    // due_coupons = self.due_coupons_watermark
    intc_0 // 0
    bytec 23 // "due_coupons_watermark"
    app_global_get_ex
    swap
    cover 2
    assert // check self.due_coupons_watermark exists
    // smart_contracts/fixed_coupon_bond/contract.py:53
    // if current_ts >= self.maturity_date:
    intc_0 // 0
    bytec 7 // "maturity_date"
    app_global_get_ex
    assert // check self.maturity_date exists
    >=
    bz count_due_coupons_else_body@2
    // smart_contracts/fixed_coupon_bond/contract.py:54
    // due_coupons = self.total_coupons
    intc_0 // 0
    bytec 5 // "total_coupons"
    app_global_get_ex
    swap
    frame_bury 2
    assert // check self.total_coupons exists

count_due_coupons_after_if_else@8:
    // smart_contracts/fixed_coupon_bond/contract.py:66
    // self.due_coupons_watermark = due_coupons
    bytec 23 // "due_coupons_watermark"
    frame_dig 2
    dup
    cover 2
    app_global_put
    // smart_contracts/fixed_coupon_bond/contract.py:67
    // return due_coupons
    frame_bury 0
    retsub

count_due_coupons_else_body@2:
    // smart_contracts/fixed_coupon_bond/contract.py:55
    // elif current_ts > self.issuance_date:
    intc_0 // 0
    bytec 6 // "issuance_date"
    app_global_get_ex
    assert // check self.issuance_date exists
    frame_dig 1
    <
    bz count_due_coupons_after_if_else@8
    // smart_contracts/fixed_coupon_bond/contract.py:56
    // coupon_idx = UInt64(cfg.FIRST_COUPON_DATE_IDX) + self.due_coupons_watermark
    intc_0 // 0
    bytec 23 // "due_coupons_watermark"
    app_global_get_ex
    assert // check self.due_coupons_watermark exists
    pushint 3
    +
    dup
    frame_bury 0
    // smart_contracts/fixed_coupon_bond/contract.py:57
    // coupon_due_date = self.time_events.value[coupon_idx]
    intc_3 // 8
    *
    pushint 2
    +
    bytec 10 // 0x74696d654576656e7473
    swap
    intc_3 // 8
    box_extract
    btoi

count_due_coupons_while_top@4:
    // smart_contracts/fixed_coupon_bond/contract.py:58
    // while current_ts >= coupon_due_date:
    frame_dig 1
    <=
    bz count_due_coupons_after_while@6
    // smart_contracts/fixed_coupon_bond/contract.py:60
    // required_budget=UInt64(cfg.OP_UP_COUPON_DUE_COUNTING),
    intc 5 // 255
    // smart_contracts/fixed_coupon_bond/contract.py:61
    // fee_source=OpUpFeeSource.GroupCredit,
    intc_0 // 0
    // smart_contracts/fixed_coupon_bond/contract.py:59-62
    // ensure_budget(
    //     required_budget=UInt64(cfg.OP_UP_COUPON_DUE_COUNTING),
    //     fee_source=OpUpFeeSource.GroupCredit,
    // )
    callsub ensure_budget
    // smart_contracts/fixed_coupon_bond/contract.py:63
    // coupon_idx += 1
    frame_dig 0
    intc_1 // 1
    +
    dup
    frame_bury 0
    // smart_contracts/fixed_coupon_bond/contract.py:64
    // coupon_due_date = self.time_events.value[coupon_idx]
    intc_3 // 8
    *
    pushint 2
    +
    bytec 10 // 0x74696d654576656e7473
    swap
    intc_3 // 8
    box_extract
    btoi
    b count_due_coupons_while_top@4

count_due_coupons_after_while@6:
    // smart_contracts/fixed_coupon_bond/contract.py:65
    // due_coupons = coupon_idx - cfg.FIRST_COUPON_DATE_IDX
    frame_dig 0
    pushint 3
    -
    frame_bury 2
    b count_due_coupons_after_if_else@8


// smart_contracts.fixed_coupon_bond.contract.FixedCouponBond.coupon_due_date(coupon: uint64) -> uint64:
coupon_due_date:
    // smart_contracts/fixed_coupon_bond/contract.py:69
    // def coupon_due_date(self, coupon: UInt64) -> UInt64:
    proto 1 1
    // smart_contracts/fixed_coupon_bond/contract.py:70
    // return self.time_events.value[cfg.FIRST_COUPON_DATE_IDX + coupon - 1]
    pushint 3
    frame_dig -1
    +
    intc_1 // 1
    -
    intc_3 // 8
    *
    pushint 2
    +
    bytec 10 // 0x74696d654576656e7473
    swap
    intc_3 // 8
    box_extract
    btoi
    retsub


// smart_contracts.fixed_coupon_bond.contract.FixedCouponBond.next_coupon_due_date(due_coupons: uint64) -> uint64:
next_coupon_due_date:
    // smart_contracts/fixed_coupon_bond/contract.py:78
    // def next_coupon_due_date(self, due_coupons: UInt64) -> UInt64:
    proto 1 1
    // smart_contracts/fixed_coupon_bond/contract.py:79
    // coupon_due_date = UInt64()
    intc_0 // 0
    // smart_contracts/fixed_coupon_bond/contract.py:80
    // if due_coupons < self.total_coupons:
    dup
    bytec 5 // "total_coupons"
    app_global_get_ex
    assert // check self.total_coupons exists
    frame_dig -1
    >
    bz next_coupon_due_date_after_if_else@2
    // smart_contracts/fixed_coupon_bond/contract.py:81
    // coupon_due_date = self.coupon_due_date(due_coupons + 1)
    frame_dig -1
    intc_1 // 1
    +
    callsub coupon_due_date
    frame_bury 0

next_coupon_due_date_after_if_else@2:
    // smart_contracts/fixed_coupon_bond/contract.py:82
    // return coupon_due_date
    frame_dig 0
    swap
    retsub


// smart_contracts.fixed_coupon_bond.contract.FixedCouponBond.all_due_coupons_paid(due_coupons: uint64) -> uint64:
all_due_coupons_paid:
    // smart_contracts/fixed_coupon_bond/contract.py:84
    // def all_due_coupons_paid(self, due_coupons: UInt64) -> bool:
    proto 1 1
    // smart_contracts/fixed_coupon_bond/contract.py:85
    // return self.paid_coupon_units >= self.circulating_units * due_coupons
    intc_0 // 0
    bytec 24 // "paid_coupon_units"
    app_global_get_ex
    assert // check self.paid_coupon_units exists
    intc_0 // 0
    bytec 4 // "circulating_units"
    app_global_get_ex
    assert // check self.circulating_units exists
    frame_dig -1
    *
    >=
    retsub


// smart_contracts.fixed_coupon_bond.contract.FixedCouponBond.assert_no_pending_coupon_payment(holding_address: bytes, due_coupons: uint64) -> void:
assert_no_pending_coupon_payment:
    // smart_contracts/fixed_coupon_bond/contract.py:87-89
    // def assert_no_pending_coupon_payment(
    //     self, holding_address: Account, due_coupons: UInt64
    // ) -> None:
    proto 2 0
    // smart_contracts/fixed_coupon_bond/contract.py:91
    // self.account[holding_address].paid_coupons == due_coupons
    bytec_1 // 0x52333023
    frame_dig -2
    concat
    box_get
    assert // check self.account entry exists
    pushint 48
    extract_uint64
    frame_dig -1
    ==
    // smart_contracts/fixed_coupon_bond/contract.py:90-92
    // assert (
    //     self.account[holding_address].paid_coupons == due_coupons
    // ), err.PENDING_COUPON_PAYMENT
    assert // Pending due coupon payment
    retsub


// smart_contracts.fixed_coupon_bond.contract.FixedCouponBond.coupon_interest_amount(principal_amount: uint64, coupon: uint64) -> uint64:
coupon_interest_amount:
    // smart_contracts/fixed_coupon_bond/contract.py:94-96
    // def coupon_interest_amount(
    //     self, principal_amount: UInt64, coupon: UInt64
    // ) -> UInt64:
    proto 2 1
    // smart_contracts/fixed_coupon_bond/contract.py:97
    // coupon_rate_bps = self.coupon_rates.value[coupon - 1].as_uint64()
    frame_dig -1
    intc_1 // 1
    -
    pushint 2
    *
    pushint 2
    +
    bytec 15 // 0x636f75706f6e5261746573
    swap
    pushint 2
    box_extract
    btoi
    // smart_contracts/fixed_coupon_bond/contract.py:98
    // return principal_amount * coupon_rate_bps // cst.BPS
    frame_dig -2
    *
    pushint 10000
    /
    retsub


// smart_contracts.fixed_coupon_bond.contract.FixedCouponBond.day_count_factor(due_coupons: uint64) -> bytes:
day_count_factor:
    // smart_contracts/fixed_coupon_bond/contract.py:100
    // def day_count_factor(self, due_coupons: UInt64) -> typ.DayCountFactor:
    proto 1 1
    bytec_3 // ""
    dup
    // smart_contracts/fixed_coupon_bond/contract.py:101-102
    // # The reference implementation supports only the Actual/Actual and Continuous day-count conventions
    // if not due_coupons:
    frame_dig -1
    bnz day_count_factor_else_body@2
    // smart_contracts/fixed_coupon_bond/contract.py:103
    // accruing_start_time = self.issuance_date
    intc_0 // 0
    bytec 6 // "issuance_date"
    app_global_get_ex
    assert // check self.issuance_date exists

day_count_factor_after_if_else@3:
    // smart_contracts/fixed_coupon_bond/contract.py:106
    // coupon_accrued_period = Global.latest_timestamp - accruing_start_time
    global LatestTimestamp
    dig 1
    -
    frame_bury 0
    // smart_contracts/fixed_coupon_bond/contract.py:107
    // coupon_period = self.next_coupon_due_date(due_coupons) - accruing_start_time
    frame_dig -1
    callsub next_coupon_due_date
    swap
    -
    // smart_contracts/fixed_coupon_bond/contract.py:108
    // if self.day_count_convention == UInt64(cst.DCC_A_A):
    intc_0 // 0
    bytec 11 // "day_count_convention"
    app_global_get_ex
    assert // check self.day_count_convention exists
    bnz day_count_factor_after_if_else@5
    // smart_contracts/base_d_asa/contract.py:313
    // return time_period // UInt64(cst.DAY_2_SEC)
    frame_dig 0
    intc 7 // 86400
    /
    frame_bury 0
    intc 7 // 86400
    /

day_count_factor_after_if_else@5:
    // smart_contracts/fixed_coupon_bond/contract.py:111-114
    // return typ.DayCountFactor(
    //     numerator=coupon_accrued_period,
    //     denominator=coupon_period,
    // )
    frame_dig 0
    itob
    swap
    itob
    concat
    frame_bury 0
    retsub

day_count_factor_else_body@2:
    // smart_contracts/fixed_coupon_bond/contract.py:73
    // coupon_due_date = UInt64()
    intc_0 // 0
    frame_bury 1
    // smart_contracts/fixed_coupon_bond/contract.py:74
    // if due_coupons >= UInt64(1):
    frame_dig -1
    bz day_count_factor_after_if_else@8
    // smart_contracts/fixed_coupon_bond/contract.py:75
    // coupon_due_date = self.coupon_due_date(due_coupons)
    frame_dig -1
    callsub coupon_due_date
    frame_bury 1

day_count_factor_after_if_else@8:
    frame_dig 1
    b day_count_factor_after_if_else@3


// smart_contracts.fixed_coupon_bond.contract.FixedCouponBond.is_accruing_interest(due_coupons: uint64) -> uint64:
is_accruing_interest:
    // smart_contracts/fixed_coupon_bond/contract.py:116
    // def is_accruing_interest(self, due_coupons: UInt64) -> bool:
    proto 1 1
    // smart_contracts/fixed_coupon_bond/contract.py:118
    // self.issuance_date != 0
    intc_0 // 0
    bytec 6 // "issuance_date"
    app_global_get_ex
    assert // check self.issuance_date exists
    // smart_contracts/fixed_coupon_bond/contract.py:118-120
    // self.issuance_date != 0
    // and Global.latest_timestamp >= self.issuance_date
    // and due_coupons < self.total_coupons
    bz is_accruing_interest_bool_false@4
    // smart_contracts/fixed_coupon_bond/contract.py:119
    // and Global.latest_timestamp >= self.issuance_date
    global LatestTimestamp
    intc_0 // 0
    bytec 6 // "issuance_date"
    app_global_get_ex
    assert // check self.issuance_date exists
    >=
    // smart_contracts/fixed_coupon_bond/contract.py:118-120
    // self.issuance_date != 0
    // and Global.latest_timestamp >= self.issuance_date
    // and due_coupons < self.total_coupons
    bz is_accruing_interest_bool_false@4
    // smart_contracts/fixed_coupon_bond/contract.py:120
    // and due_coupons < self.total_coupons
    intc_0 // 0
    bytec 5 // "total_coupons"
    app_global_get_ex
    assert // check self.total_coupons exists
    frame_dig -1
    >
    // smart_contracts/fixed_coupon_bond/contract.py:118-120
    // self.issuance_date != 0
    // and Global.latest_timestamp >= self.issuance_date
    // and due_coupons < self.total_coupons
    bz is_accruing_interest_bool_false@4
    intc_1 // 1
    // smart_contracts/fixed_coupon_bond/contract.py:117-121
    // return (
    //     self.issuance_date != 0
    //     and Global.latest_timestamp >= self.issuance_date
    //     and due_coupons < self.total_coupons
    // )
    retsub

is_accruing_interest_bool_false@4:
    intc_0 // 0
    // smart_contracts/fixed_coupon_bond/contract.py:117-121
    // return (
    //     self.issuance_date != 0
    //     and Global.latest_timestamp >= self.issuance_date
    //     and due_coupons < self.total_coupons
    // )
    retsub


// smart_contracts.fixed_coupon_bond.contract.FixedCouponBond.accrued_interest_amount(holding_address: bytes, units: uint64, due_coupons: uint64) -> uint64:
accrued_interest_amount:
    // smart_contracts/fixed_coupon_bond/contract.py:123-125
    // def accrued_interest_amount(
    //     self, holding_address: Account, units: UInt64, due_coupons: UInt64
    // ) -> UInt64:
    proto 3 1
    // smart_contracts/fixed_coupon_bond/contract.py:126-127
    // # The following assert safeguards the subroutine from forbidden invocations
    // self.assert_no_pending_coupon_payment(holding_address, due_coupons)
    frame_dig -3
    frame_dig -1
    callsub assert_no_pending_coupon_payment
    // smart_contracts/fixed_coupon_bond/contract.py:128
    // day_count_factor = self.day_count_factor(due_coupons)
    frame_dig -1
    callsub day_count_factor
    // smart_contracts/fixed_coupon_bond/contract.py:129
    // coupon_accrued_period = day_count_factor.numerator
    dup
    intc_0 // 0
    extract_uint64
    // smart_contracts/fixed_coupon_bond/contract.py:130
    // coupon_period = day_count_factor.denominator
    swap
    intc_3 // 8
    extract_uint64
    // smart_contracts/fixed_coupon_bond/contract.py:131-133
    // next_coupon_rate_bps = self.coupon_rates.value[
    //     due_coupons
    // ].as_uint64()  # due_coupons is equal to the 0-base idx of next coupon
    frame_dig -1
    pushint 2
    *
    pushint 2
    +
    // smart_contracts/fixed_coupon_bond/contract.py:131
    // next_coupon_rate_bps = self.coupon_rates.value[
    bytec 15 // 0x636f75706f6e5261746573
    // smart_contracts/fixed_coupon_bond/contract.py:131-133
    // next_coupon_rate_bps = self.coupon_rates.value[
    //     due_coupons
    // ].as_uint64()  # due_coupons is equal to the 0-base idx of next coupon
    swap
    pushint 2
    box_extract
    btoi
    // smart_contracts/fixed_coupon_bond/contract.py:135
    // self.account_units_value(holding_address, units)
    frame_dig -3
    frame_dig -2
    callsub account_units_value
    // smart_contracts/fixed_coupon_bond/contract.py:135-136
    // self.account_units_value(holding_address, units)
    // * next_coupon_rate_bps
    *
    // smart_contracts/fixed_coupon_bond/contract.py:135-137
    // self.account_units_value(holding_address, units)
    // * next_coupon_rate_bps
    // * coupon_accrued_period
    uncover 2
    *
    // smart_contracts/fixed_coupon_bond/contract.py:139
    // cst.BPS * coupon_period
    pushint 10000
    uncover 2
    *
    // smart_contracts/fixed_coupon_bond/contract.py:135-140
    // self.account_units_value(holding_address, units)
    // * next_coupon_rate_bps
    // * coupon_accrued_period
    // // (
    //     cst.BPS * coupon_period
    // )  # div-by-zero: coupon_period != 0 due to assert_time_events_sorted checks
    /
    // smart_contracts/fixed_coupon_bond/contract.py:134-141
    // return (
    //     self.account_units_value(holding_address, units)
    //     * next_coupon_rate_bps
    //     * coupon_accrued_period
    //     // (
    //         cst.BPS * coupon_period
    //     )  # div-by-zero: coupon_period != 0 due to assert_time_events_sorted checks
    // )
    retsub


// smart_contracts.base_d_asa.contract.BaseDAsa.assert_is_not_defaulted() -> void:
assert_is_not_defaulted:
    // smart_contracts/base_d_asa/contract.py:106
    // assert not self.defaulted, err.DEFAULTED
    intc_0 // 0
    bytec 22 // "defaulted"
    app_global_get_ex
    assert // check self.defaulted exists
    !
    assert // Defaulted
    retsub


// smart_contracts.base_d_asa.contract.BaseDAsa.assert_is_not_suspended() -> void:
assert_is_not_suspended:
    // smart_contracts/base_d_asa/contract.py:109
    // assert not self.suspended, err.SUSPENDED
    intc_0 // 0
    bytec 21 // "suspended"
    app_global_get_ex
    assert // check self.suspended exists
    !
    assert // Suspended operations
    retsub


// smart_contracts.base_d_asa.contract.BaseDAsa.assert_caller_is_arranger() -> void:
assert_caller_is_arranger:
    // smart_contracts/base_d_asa/contract.py:112
    // assert Txn.sender == self.arranger.value, err.UNAUTHORIZED
    txn Sender
    intc_0 // 0
    bytec 16 // 0x52323023
    app_global_get_ex
    assert // check self.arranger exists
    ==
    assert // Not authorized
    retsub


// smart_contracts.base_d_asa.contract.BaseDAsa.assert_caller_is_account_manager() -> void:
assert_caller_is_account_manager:
    // smart_contracts/base_d_asa/contract.py:114
    // def assert_caller_is_account_manager(self) -> None:
    proto 0 0
    bytec_3 // ""
    // smart_contracts/base_d_asa/contract.py:117
    // caller in self.account_manager
    bytec 31 // 0x52343023
    // smart_contracts/base_d_asa/contract.py:115
    // caller = Txn.sender
    txn Sender
    // smart_contracts/base_d_asa/contract.py:117
    // caller in self.account_manager
    concat
    dup
    box_len
    bury 1
    // smart_contracts/base_d_asa/contract.py:117-120
    // caller in self.account_manager
    // and self.account_manager[caller].role_validity_start
    // <= Global.latest_timestamp
    // <= self.account_manager[caller].role_validity_end
    bz assert_caller_is_account_manager_bool_false@4
    // smart_contracts/base_d_asa/contract.py:118
    // and self.account_manager[caller].role_validity_start
    frame_dig 1
    box_get
    assert // check self.account_manager entry exists
    intc_0 // 0
    extract_uint64
    // smart_contracts/base_d_asa/contract.py:119
    // <= Global.latest_timestamp
    global LatestTimestamp
    dup
    frame_bury 0
    // smart_contracts/base_d_asa/contract.py:118-119
    // and self.account_manager[caller].role_validity_start
    // <= Global.latest_timestamp
    <=
    // smart_contracts/base_d_asa/contract.py:118-120
    // and self.account_manager[caller].role_validity_start
    // <= Global.latest_timestamp
    // <= self.account_manager[caller].role_validity_end
    bz assert_caller_is_account_manager_bool_false@4
    // smart_contracts/base_d_asa/contract.py:120
    // <= self.account_manager[caller].role_validity_end
    frame_dig 1
    box_get
    assert // check self.account_manager entry exists
    intc_3 // 8
    extract_uint64
    // smart_contracts/base_d_asa/contract.py:119-120
    // <= Global.latest_timestamp
    // <= self.account_manager[caller].role_validity_end
    frame_dig 0
    >=
    // smart_contracts/base_d_asa/contract.py:118-120
    // and self.account_manager[caller].role_validity_start
    // <= Global.latest_timestamp
    // <= self.account_manager[caller].role_validity_end
    bz assert_caller_is_account_manager_bool_false@4
    intc_1 // 1

assert_caller_is_account_manager_bool_merge@5:
    // smart_contracts/base_d_asa/contract.py:116-121
    // assert (
    //     caller in self.account_manager
    //     and self.account_manager[caller].role_validity_start
    //     <= Global.latest_timestamp
    //     <= self.account_manager[caller].role_validity_end
    // ), err.UNAUTHORIZED
    assert // Not authorized
    retsub

assert_caller_is_account_manager_bool_false@4:
    intc_0 // 0
    b assert_caller_is_account_manager_bool_merge@5


// smart_contracts.base_d_asa.contract.BaseDAsa.assert_caller_is_authority() -> void:
assert_caller_is_authority:
    // smart_contracts/base_d_asa/contract.py:141
    // def assert_caller_is_authority(self) -> None:
    proto 0 0
    bytec_3 // ""
    // smart_contracts/base_d_asa/contract.py:144
    // caller in self.authority
    bytec 28 // 0x52373023
    // smart_contracts/base_d_asa/contract.py:142
    // caller = Txn.sender
    txn Sender
    // smart_contracts/base_d_asa/contract.py:144
    // caller in self.authority
    concat
    dup
    box_len
    bury 1
    // smart_contracts/base_d_asa/contract.py:144-147
    // caller in self.authority
    // and self.authority[caller].role_validity_start
    // <= Global.latest_timestamp
    // <= self.authority[caller].role_validity_end
    bz assert_caller_is_authority_bool_false@4
    // smart_contracts/base_d_asa/contract.py:145
    // and self.authority[caller].role_validity_start
    frame_dig 1
    box_get
    assert // check self.authority entry exists
    intc_0 // 0
    extract_uint64
    // smart_contracts/base_d_asa/contract.py:146
    // <= Global.latest_timestamp
    global LatestTimestamp
    dup
    frame_bury 0
    // smart_contracts/base_d_asa/contract.py:145-146
    // and self.authority[caller].role_validity_start
    // <= Global.latest_timestamp
    <=
    // smart_contracts/base_d_asa/contract.py:145-147
    // and self.authority[caller].role_validity_start
    // <= Global.latest_timestamp
    // <= self.authority[caller].role_validity_end
    bz assert_caller_is_authority_bool_false@4
    // smart_contracts/base_d_asa/contract.py:147
    // <= self.authority[caller].role_validity_end
    frame_dig 1
    box_get
    assert // check self.authority entry exists
    intc_3 // 8
    extract_uint64
    // smart_contracts/base_d_asa/contract.py:146-147
    // <= Global.latest_timestamp
    // <= self.authority[caller].role_validity_end
    frame_dig 0
    >=
    // smart_contracts/base_d_asa/contract.py:145-147
    // and self.authority[caller].role_validity_start
    // <= Global.latest_timestamp
    // <= self.authority[caller].role_validity_end
    bz assert_caller_is_authority_bool_false@4
    intc_1 // 1

assert_caller_is_authority_bool_merge@5:
    // smart_contracts/base_d_asa/contract.py:143-148
    // assert (
    //     caller in self.authority
    //     and self.authority[caller].role_validity_start
    //     <= Global.latest_timestamp
    //     <= self.authority[caller].role_validity_end
    // ), err.UNAUTHORIZED
    assert // Not authorized
    retsub

assert_caller_is_authority_bool_false@4:
    intc_0 // 0
    b assert_caller_is_authority_bool_merge@5


// smart_contracts.base_d_asa.contract.BaseDAsa.assert_time_events_sorted(time_events: bytes) -> bytes:
assert_time_events_sorted:
    // smart_contracts/base_d_asa/contract.py:218
    // def assert_time_events_sorted(self, time_events: typ.TimeEvents) -> None:
    proto 1 1
    bytec_3 // ""
    dupn 2
    // smart_contracts/base_d_asa/contract.py:220
    // time_events[cfg.PRIMARY_DISTRIBUTION_OPENING_DATE_IDX]
    frame_dig -1
    extract 2 0
    frame_dig -1
    pushint 2
    extract_uint64
    // smart_contracts/base_d_asa/contract.py:221
    // > Global.latest_timestamp
    global LatestTimestamp
    // smart_contracts/base_d_asa/contract.py:220-221
    // time_events[cfg.PRIMARY_DISTRIBUTION_OPENING_DATE_IDX]
    // > Global.latest_timestamp
    >
    // smart_contracts/base_d_asa/contract.py:219-222
    // assert (
    //     time_events[cfg.PRIMARY_DISTRIBUTION_OPENING_DATE_IDX]
    //     > Global.latest_timestamp
    // ), err.INVALID_TIME
    assert // Time events must be set in the future
    // smart_contracts/base_d_asa/contract.py:223
    // for _t in urange(time_events.length - 1):
    frame_dig -1
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_1 // 1
    -
    intc_0 // 0

assert_time_events_sorted_for_header@1:
    // smart_contracts/base_d_asa/contract.py:223
    // for _t in urange(time_events.length - 1):
    frame_dig 5
    frame_dig 4
    <
    bz assert_time_events_sorted_after_for@6
    // smart_contracts/base_d_asa/contract.py:225
    // required_budget=UInt64(cfg.OP_UP_TIME_EVENT_SORTING),
    pushint 65
    // smart_contracts/base_d_asa/contract.py:226
    // fee_source=OpUpFeeSource.AppAccount,  # App funds are not at risk since caller is trusted
    intc_1 // 1
    // smart_contracts/base_d_asa/contract.py:224-227
    // ensure_budget(
    //     required_budget=UInt64(cfg.OP_UP_TIME_EVENT_SORTING),
    //     fee_source=OpUpFeeSource.AppAccount,  # App funds are not at risk since caller is trusted
    // )
    callsub ensure_budget
    // smart_contracts/base_d_asa/contract.py:228
    // time_i = time_events[_t]
    frame_dig 5
    dup
    intc_3 // 8
    *
    frame_dig 3
    dup
    cover 3
    swap
    extract_uint64
    dup
    cover 3
    frame_bury 1
    // smart_contracts/base_d_asa/contract.py:229
    // time_f = time_events[_t + 1]
    intc_1 // 1
    +
    dup
    frame_bury 2
    intc_3 // 8
    *
    extract_uint64
    dup
    frame_bury 0
    // smart_contracts/base_d_asa/contract.py:230
    // assert time_f > time_i, err.INVALID_SORTING
    <
    assert // Time events must be sorted in strictly ascending order
    // smart_contracts/base_d_asa/contract.py:231
    // if self.day_count_convention != UInt64(cst.DCC_CONT):
    intc_0 // 0
    bytec 11 // "day_count_convention"
    app_global_get_ex
    assert // check self.day_count_convention exists
    intc 5 // 255
    !=
    bz assert_time_events_sorted_after_if_else@4
    // smart_contracts/base_d_asa/contract.py:232-233
    // # The reference implementation requires time periods expressed in days for regular day-count conventions
    // assert (time_f - time_i) % UInt64(
    frame_dig 0
    frame_dig 1
    -
    // smart_contracts/base_d_asa/contract.py:232-235
    // # The reference implementation requires time periods expressed in days for regular day-count conventions
    // assert (time_f - time_i) % UInt64(
    //     cst.DAY_2_SEC
    // ) == 0, err.INVALID_TIME_PERIOD
    intc 7 // 86400
    %
    !
    assert // Time periods in Actual/Actual day count convention must be multiples of a day (in seconds)

assert_time_events_sorted_after_if_else@4:
    frame_dig 2
    frame_bury 5
    b assert_time_events_sorted_for_header@1

assert_time_events_sorted_after_for@6:
    frame_dig -1
    frame_bury 0
    retsub


// smart_contracts.base_d_asa.contract.BaseDAsa.is_payment_executable(holding_address: bytes) -> uint64:
is_payment_executable:
    // smart_contracts/base_d_asa/contract.py:279
    // def is_payment_executable(self, holding_address: Account) -> bool:
    proto 1 1
    // smart_contracts/base_d_asa/contract.py:281
    // self.account[holding_address].payment_address.is_opted_in(
    bytec_1 // 0x52333023
    frame_dig -1
    concat
    dup
    box_get
    assert // check self.account entry exists
    extract 0 32
    // smart_contracts/base_d_asa/contract.py:282
    // Asset(self.settlement_asset_id)
    intc_0 // 0
    bytec 8 // "settlement_asset_id"
    app_global_get_ex
    assert // check self.settlement_asset_id exists
    // smart_contracts/base_d_asa/contract.py:281-283
    // self.account[holding_address].payment_address.is_opted_in(
    //     Asset(self.settlement_asset_id)
    // )
    asset_holding_get AssetBalance
    bury 1
    // smart_contracts/base_d_asa/contract.py:281-284
    // self.account[holding_address].payment_address.is_opted_in(
    //     Asset(self.settlement_asset_id)
    // )
    // and not self.account[holding_address].suspended
    bz is_payment_executable_bool_false@3
    // smart_contracts/base_d_asa/contract.py:284
    // and not self.account[holding_address].suspended
    frame_dig 0
    box_get
    assert // check self.account entry exists
    intc 4 // 448
    getbit
    bnz is_payment_executable_bool_false@3
    intc_1 // 1

is_payment_executable_bool_merge@4:
    // smart_contracts/base_d_asa/contract.py:280-285
    // return (
    //     self.account[holding_address].payment_address.is_opted_in(
    //         Asset(self.settlement_asset_id)
    //     )
    //     and not self.account[holding_address].suspended
    // )
    swap
    retsub

is_payment_executable_bool_false@3:
    intc_0 // 0
    b is_payment_executable_bool_merge@4


// smart_contracts.base_d_asa.contract.BaseDAsa.assert_enough_funds(payment_amount: uint64) -> void:
assert_enough_funds:
    // smart_contracts/base_d_asa/contract.py:287
    // def assert_enough_funds(self, payment_amount: UInt64) -> None:
    proto 1 0
    // smart_contracts/base_d_asa/contract.py:289
    // Asset(self.settlement_asset_id).balance(Global.current_application_address)
    global CurrentApplicationAddress
    intc_0 // 0
    bytec 8 // "settlement_asset_id"
    app_global_get_ex
    assert // check self.settlement_asset_id exists
    asset_holding_get AssetBalance
    assert // account opted into asset
    // smart_contracts/base_d_asa/contract.py:289-290
    // Asset(self.settlement_asset_id).balance(Global.current_application_address)
    // >= payment_amount
    frame_dig -1
    >=
    // smart_contracts/base_d_asa/contract.py:288-291
    // assert (
    //     Asset(self.settlement_asset_id).balance(Global.current_application_address)
    //     >= payment_amount
    // ), err.NOT_ENOUGH_FUNDS
    assert // Not enough funds for the payment
    retsub


// smart_contracts.base_d_asa.contract.BaseDAsa.pay(receiver: bytes, amount: uint64) -> void:
pay:
    // smart_contracts/base_d_asa/contract.py:293
    // def pay(self, receiver: Account, amount: UInt64) -> None:
    proto 2 0
    // smart_contracts/base_d_asa/contract.py:294-299
    // itxn.AssetTransfer(
    //     xfer_asset=self.settlement_asset_id,
    //     asset_receiver=receiver,
    //     asset_amount=amount,
    //     fee=Global.min_txn_fee,
    // ).submit()
    itxn_begin
    // smart_contracts/base_d_asa/contract.py:298
    // fee=Global.min_txn_fee,
    global MinTxnFee
    // smart_contracts/base_d_asa/contract.py:295
    // xfer_asset=self.settlement_asset_id,
    intc_0 // 0
    bytec 8 // "settlement_asset_id"
    app_global_get_ex
    assert // check self.settlement_asset_id exists
    frame_dig -1
    itxn_field AssetAmount
    frame_dig -2
    itxn_field AssetReceiver
    itxn_field XferAsset
    // smart_contracts/base_d_asa/contract.py:294
    // itxn.AssetTransfer(
    pushint 4 // axfer
    itxn_field TypeEnum
    itxn_field Fee
    // smart_contracts/base_d_asa/contract.py:294-299
    // itxn.AssetTransfer(
    //     xfer_asset=self.settlement_asset_id,
    //     asset_receiver=receiver,
    //     asset_amount=amount,
    //     fee=Global.min_txn_fee,
    // ).submit()
    itxn_submit
    retsub


// smart_contracts.base_d_asa.contract.BaseDAsa.account_units_value(holding_address: bytes, units: uint64) -> uint64:
account_units_value:
    // smart_contracts/base_d_asa/contract.py:304
    // def account_units_value(self, holding_address: Account, units: UInt64) -> UInt64:
    proto 2 1
    // smart_contracts/base_d_asa/contract.py:305
    // return units * self.account[holding_address].unit_value
    bytec_1 // 0x52333023
    frame_dig -2
    concat
    box_get
    assert // check self.account entry exists
    pushint 40
    extract_uint64
    frame_dig -1
    *
    retsub


// smart_contracts.base_d_asa.contract.BaseDAsa.account_total_units_value(holding_address: bytes) -> uint64:
account_total_units_value:
    // smart_contracts/base_d_asa/contract.py:307
    // def account_total_units_value(self, holding_address: Account) -> UInt64:
    proto 1 1
    // smart_contracts/base_d_asa/contract.py:309
    // holding_address, self.account[holding_address].units
    bytec_1 // 0x52333023
    frame_dig -1
    concat
    box_get
    assert // check self.account entry exists
    intc_2 // 32
    extract_uint64
    // smart_contracts/base_d_asa/contract.py:308-310
    // return self.account_units_value(
    //     holding_address, self.account[holding_address].units
    // )
    frame_dig -1
    swap
    callsub account_units_value
    retsub


// smart_contracts.base_d_asa.contract.BaseDAsa.end_if_no_circulating_units() -> void:
end_if_no_circulating_units:
    // smart_contracts/base_d_asa/contract.py:321
    // if self.circulating_units == 0:
    intc_0 // 0
    bytec 4 // "circulating_units"
    app_global_get_ex
    assert // check self.circulating_units exists
    bnz end_if_no_circulating_units_after_if_else@2
    // smart_contracts/base_d_asa/contract.py:322
    // self.status = UInt64(cfg.STATUS_ENDED)
    bytec_2 // "status"
    intc 6 // 200
    app_global_put

end_if_no_circulating_units_after_if_else@2:
    retsub
